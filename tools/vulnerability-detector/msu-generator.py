# This script generates a JSON feed which relates the 
# vulnerabilities of Microsoft products and the hotfixes 
# that solve them. Vulnerability vulnerable or not.
#
# Copyright (C) 2015-2019, Wazuh Inc.
# May 28, 2019.
#
# This program is a free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License (version 2) as published by the FSF - Free Software
# Foundation.
# Wazuh, Inc <support@wazuh.com>

from sys import argv
import json
import re
import datetime
import requests


# Global vars
feed_data = {}
supersedence_dic = {}
debug_mode = False
cve_count = 0

def debug(msg) :
    if debug_mode :
        print(msg)


def get_products_dic(raw_dic):
    products_dic = {}

    for node in raw_dic:
        products_dic[node['ProductID']] = node['Value']

    return products_dic 


def add_entry(vulnerability, title, patch, url, subtype, restart_required, product_name) :
    if not patch[0].isdigit() :
      return

    if vulnerability not in feed_data:
        feed_data[vulnerability] = []

    debug("=============")
    debug (" + vulnerability: " + vulnerability)
    debug (" + product: " + product_name)
    debug (" + patch: " + patch)  
    try:
        debug (" + title: " + title.decode('utf-8'))
    except UnicodeEncodeError:
        debug ("Invalid title from {0} vulnerability".format(vulnerability))
        title = "{0} vulnerability".format(vulnerability)
    debug (" + url: " + url)
    debug (" + subtype: " + subtype)
    debug (" + restart_required: " + restart_required)

    feed_data[vulnerability].append({'product': product_name, 'patch': patch, 'title': title, 
            'url': url, 'subtype': subtype, 'restart_required': restart_required})


def add_supersedence(patch, supersedence):
    if supersedence is '-':
        return

    debug("The supersedence {0} must be parsed.".format(supersedence))
    supersed_array = filter(None, re.split(' |,|;|<br><br>', supersedence))

    for supersed_node in supersed_array:
        if supersed_node.startswith('MS'):
            continue

        if supersed_node not in supersedence_dic:
            supersedence_dic[supersed_node] = []

        patch_sups = supersedence_dic[supersed_node]
        if patch in patch_sups:
            return

        patch_sups.append(patch)


def process_month(data):
    json_data = json.loads(data)

    if 'FullProductName' not in json_data['ProductTree'] :
        return

    products_dic = get_products_dic(json_data['ProductTree']['FullProductName'])

    for element in json_data['Vulnerability']:
        title = element['Title']['Value'] if 'Title' in element and 'Value' in element['Title'] else '-'  
        vulnerability = element['CVE']
        global cve_count
        cve_count += 1
        for remediation in element['Remediations'] :
            if 'ProductID' not in remediation:  
                continue
            patch = remediation['Description']['Value']
            url = remediation['URL'] if 'URL' in remediation else ''
            subtype = remediation['SubType'] if 'SubType' in remediation else ''
            restart_required = remediation['RestartRequired']['Value'] if 'RestartRequired' in remediation and 'Value' in remediation['RestartRequired'] else ''
            supersedence = remediation['Supersedence'] if 'Supersedence' in remediation\
                            else remediation['Supercedence'] if 'Supercedence' in remediation else '-'
            add_supersedence(patch, supersedence)
            for product in remediation['ProductID'] :
                product_name = products_dic[product]
                add_entry(vulnerability, title, patch, url, subtype, restart_required, product_name)


def add_superdence_patch(cve, upatch, patch_name):
    # Check if there is a hotfix that includes upatch_name 
    if patch_name in supersedence_dic:
        for parent_hotfix in supersedence_dic[patch_name]:
            debug("{0} is included in {1}.".format(patch_name, parent_hotfix))    
            # For each hotfix that includes patch_name,
            # adds it to the vulnerability array
            if 'supersedence' not in upatch:
                upatch['supersedence'] = []
            sup_array = upatch['supersedence']
            if parent_hotfix not in sup_array:
                sup_array.append(parent_hotfix)
                # and look for more anidates supersedences
                add_superdence_patch(cve, upatch, parent_hotfix)


def adjust_supersedence():
    for cve in feed_data:
        # For each vulnerability
        cve_obj = feed_data[cve]
        debug("Extending hotfixes for {0}.".format(cve))
        for upatch in cve_obj:
            # For each unextended patch
            # This function will add the hotfixes that
            # include the hotfix (by transitivity or not) 
            # to the same vulnerability node
            debug("Evaluating the patch '{0}' for the '{1}' product in {2} vulnerability.".format(upatch['patch'], upatch['product'], cve))
            add_superdence_patch(cve, upatch, upatch['patch'])


def generate_feed(output_file, feed_data, parsed):
    output = open(output_file, "w")
    if parsed is True:
        output.write(json.dumps(feed_data, indent=5, sort_keys=True))
    else:
        output.write(json.dumps(feed_data))
    output.close()

    global cve_count
    print("The patches for {0} vulnerabilities have been processed.".format(cve_count))


def generate_dictionary(first_year, api_key):
    headers = {'accept': 'application/json', 'api-key' : api_key}
    now = datetime.datetime.now()
    current_year = now.year
    current_month = now.strftime('%b')
    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

    for year in range(first_year, current_year + 1):
        for month in months:
            print("Downloading " +  str(year) + "/" + month + " data.")   
            url='https://api.msrc.microsoft.com/cvrf/' + str(year) + '-' + month + '?api-version=2019'    
            reply = requests.get(url, headers=headers)
            if reply.status_code is not 200 :
                debug("Resource not found.")
                continue
            process_month(reply.text)


def main(args) :
    global debug_mode
    first_year = int(argv[1])
    output_file = argv[2]
    parsed = True if argv[3] == "yes" else False
    debug_mode = True if argv[4] == "yes" else False
    api_key = argv[5]

    generate_dictionary(first_year, api_key)
    adjust_supersedence()
    generate_feed(output_file, feed_data, parsed)


if __name__ == "__main__" :
    if len(argv) != 6:
      print("Use: python ./msb_format.py <update_since> <output> <parsed_output: yes/no> <debug_mode: yes/no> <api_key>")
      exit(1)

    main(argv)
