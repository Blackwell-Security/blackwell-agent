#include "../wmodules.h"
#include "wm_vuln_detector_db.h"
#include <os_net/os_net.h>

static void wm_vuldet_free_cpe(cpe *node);
static cpe *wm_vuldet_decode_cpe(char *raw_cpe);
static char *wm_vuldet_decode_cpe_term(char *term);
static int wm_vuldet_extract_agent_cpes(agent_software *agent, sqlite3 *db);
static int wm_vuldet_update_agent_cpes(agent_software *agent, sqlite3 *db);
static void wm_vuldet_free_search_terms(vu_search_terms *s_terms);
static vu_search_terms * wm_vuldet_extract_search_terms(char *vendor, char *product, char *version, char *arch);

int wm_vuldet_nvd_cpe_parser(update_node *update, char *path, wm_vuldet_db *parsed_vulnerabilities) {
    FILE *fp;
    char buffer[OS_MAXSTR + 1];
    static char *cpe_header = "-item name=\"cpe:2.";
    size_t cpe_header_size = strlen(cpe_header);
    char *cpe_found;
    cpe_list *node_list;

    if (fp = fopen(path, "r"), !fp) {
        return OS_INVALID;
    }

    os_calloc(1, sizeof(cpe_list), node_list);
    while (fgets(buffer, OS_MAXSTR, fp)) {
        if (cpe_found = strstr(buffer, cpe_header), cpe_found) {
            char *cpe_end;
            cpe_found += cpe_header_size;
            if (cpe_found = strchr(cpe_found, ':'), cpe_found) {
                if (cpe_end = wstr_chr(++cpe_found, '"'), cpe_end) {
                    *cpe_end = '\0';
                    if (wm_vuldet_add_cpe(cpe_found, node_list, 0)) {
                        printf("Error parsing cpe line '%s'\n", buffer);
                    }
                }
            }
        }
    }

    fclose(fp);
    parsed_vulnerabilities->nvd_cpes = node_list;

    return 0;
}

int wm_vuldet_add_cpe(char *cpe_raw, cpe_list *node_list, int index) {
    cpe_node *node;
    cpe *item;

    if (item = wm_vuldet_decode_cpe(cpe_raw), !item) {
        return OS_INVALID;
    }

    item->id = index;
    os_calloc(1, sizeof(cpe_node), node);
    node->node = item;

    if(!node_list->first) {
        node_list->first = node;
    } else {
        node->prev = node_list->last;
        node_list->last->next = node;
    }

    node_list->last = node;
    return 0;
}

int wm_vuldet_insert_cpe_db(sqlite3 *db, cpe_list *node_list, char overwrite) {
    sqlite3_stmt *stmt = NULL;
    cpe_node *node_it;
    cpe *cpe_it;
    int result;
    int i;

    if (overwrite) {
        sqlite3_exec(db, vu_queries[VU_REMOVE_CPE], NULL, NULL, NULL);

        if (sqlite3_prepare_v2(db, vu_queries[VU_REMOVE_SQUENCE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }

        sqlite3_bind_text(stmt, 1, "CPE_INDEX", -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
    }


    for (i = 0, node_it = node_list->first; node_it; i++) {
        cpe_node *node_aux;
        cpe_it = node_it->node;
        if (sqlite3_prepare_v2(db, vu_queries[VU_INSERT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        if (cpe_it->id) {
            sqlite3_bind_int(stmt, 1, cpe_it->id);
        } else {
            sqlite3_bind_null(stmt, 1);
        }
        sqlite3_bind_text(stmt, 2, cpe_it->part, -1, NULL);
        sqlite3_bind_text(stmt, 3, cpe_it->vendor, -1, NULL);
        sqlite3_bind_text(stmt, 4, cpe_it->product, -1, NULL);
        sqlite3_bind_text(stmt, 5, cpe_it->version, -1, NULL);
        sqlite3_bind_text(stmt, 6, cpe_it->update, -1, NULL);
        sqlite3_bind_text(stmt, 7, cpe_it->edition, -1, NULL);
        sqlite3_bind_text(stmt, 8, cpe_it->language, -1, NULL);
        sqlite3_bind_text(stmt, 9, cpe_it->sw_edition, -1, NULL);
        sqlite3_bind_text(stmt, 10, cpe_it->target_sw, -1, NULL);
        sqlite3_bind_text(stmt, 11, cpe_it->target_hw, -1, NULL);
        sqlite3_bind_text(stmt, 12, cpe_it->other, -1, NULL);
        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
        wm_vuldet_free_cpe(cpe_it);
        free(cpe_it);
        node_aux = node_it->next;
        free(node_it);
        node_it = node_aux;
    }

    return 0;
}


char *wm_vuldet_decode_cpe_term(char *term) {
    char *decoded_term;

    term = os_strip_char(term, '\\');
    decoded_term = wstr_replace(term, "&amp;", "&");
    free(term);
    term = wstr_replace(decoded_term, "&quot;", "\"");
    free(decoded_term);

    return term;
}

cpe *wm_vuldet_decode_cpe(char *raw_cpe) {
    cpe *decoded_cpe;
    char *cpeuri;
    char *cpe_str;
    char *cpe_strnext;
    int success = 0;

    os_calloc(1, sizeof(cpe), decoded_cpe);
    os_strdup(raw_cpe, cpeuri);
    //{part}:{vendor}:{product}:{version}:{update}:{edition}:{language}:{sw_edition}:{target_sw}:{target_hw}:{other}

    if (cpe_str = wstr_chr(cpeuri, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "vendor", raw_cpe);
        goto end;
    }
    *cpe_str++ = '\0';
    os_strdup(cpeuri, decoded_cpe->part);

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "product", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->vendor);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "version", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    decoded_cpe->product = wm_vuldet_decode_cpe_term(cpe_str);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "update", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    decoded_cpe->version = wm_vuldet_decode_cpe_term(cpe_str);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "edition", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->update);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "language", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->edition);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "target_sw", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->language);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "sw_edition", raw_cpe);
        goto end; //For cpe version 2.2
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->sw_edition);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "target_hw", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->target_sw);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "other", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->target_hw);
    os_strdup(cpe_strnext, decoded_cpe->other);

    success = 1;
end:
    os_free(cpeuri);
    if (!success) {
        wm_vuldet_free_cpe(decoded_cpe);
        os_free(decoded_cpe);
    }
    return decoded_cpe;
}

void wm_vuldet_free_cpe(cpe *node) {
    free(node->part);
    free(node->vendor);
    free(node->product);
    free(node->version);
    free(node->update);
    free(node->edition);
    free(node->language);
    free(node->sw_edition);
    free(node->target_sw);
    free(node->target_hw);
    free(node->other);
}

int wm_vuldet_get_min_cpe_index(sqlite3 *db, int *min_index) {
    sqlite3_stmt *stmt = NULL;
    int success = 0;
    char close_db = 0;

    if (!db) {
        if (sqlite3_open_v2(CVE_DB, &db, SQLITE_OPEN_READONLY, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        close_db = 1;
    }

    if (sqlite3_prepare_v2(db, vu_queries[VU_MIN_CPEINDEX], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    if (wm_vuldet_step(stmt) == SQLITE_ROW) {
        if (*min_index = sqlite3_column_int(stmt, 0), *min_index >= 0) {
            *min_index = -1;
        } else {
            (*min_index)--;
        }
    } else {
        goto end;
    }
    success = 1;
end:
    sqlite3_finalize(stmt);
    if (close_db) {
        sqlite3_close_v2(db);
    }
    return !success;
}

int wm_vuldet_extract_agent_cpes(agent_software *agent, sqlite3 *db) {
    sqlite3_stmt *stmt = NULL;
    vu_search_terms *s_terms = NULL;
    vu_search_terms *pkg_terms = NULL;
    int pkg_count, cpes_count;
    char generated_cpe[OS_SIZE_128 + 1];
    int min_cpe_index;
    int success = 0;
    vu_search_terms *f_pkg_terms;
    cpe_list *node_list = NULL;

    // If it is a Windows agent ~~~~~~~~~

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_PACK_WITHOUT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        char *vendor = (char *) sqlite3_column_text(stmt, 0);
        char *product = (char *) sqlite3_column_text(stmt, 1);
        char *version = (char *) sqlite3_column_text(stmt, 2);
        char *arch = (char *) sqlite3_column_text(stmt, 3);

        if (pkg_terms = wm_vuldet_extract_search_terms(vendor, product, version, arch), !pkg_terms) {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_GEN_SEARCH_TERMS_ERROR, vendor, product, version, arch, agent->agent_id);
            continue;
        }

        if (s_terms) {
            s_terms->next = pkg_terms;
            pkg_terms->prev = s_terms;
        }
        s_terms = pkg_terms;
    }
    sqlite3_finalize(stmt);

    // Use the search terms to find a valid CPE for each package
    for (pkg_count = 0, cpes_count = 0, pkg_terms = s_terms; pkg_terms;) {
        int v_index, p_index;
        pkg_count++;
        for (v_index = 0; pkg_terms->vendor_terms[v_index]; v_index++) {
            char *part = NULL;
            for (p_index = 0; pkg_terms->product_terms[p_index]; p_index++) {
                if (sqlite3_prepare_v2(db, vu_queries[VU_SEARCH_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                    return wm_vuldet_sql_error(db, stmt);
                }

                sqlite3_bind_text(stmt, 1, pkg_terms->vendor_terms[v_index], -1, NULL);
                sqlite3_bind_text(stmt, 2, pkg_terms->product_terms[p_index], -1, NULL);

                if (wm_vuldet_step(stmt) == SQLITE_ROW) {
                    part = (char *) sqlite3_column_text(stmt, 0);
                    snprintf(generated_cpe, OS_SIZE_128, "%c:%s:%s:%s:*:*:*:*:*:%s:*", *part,
                        pkg_terms->vendor_terms[v_index], pkg_terms->product_terms[p_index],
                        pkg_terms->o_version, pkg_terms->o_arch);
                    str_lowercase(generated_cpe);
                    sqlite3_finalize(stmt);
                    mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_CPE_GENERATED, pkg_terms->o_vendor, pkg_terms->o_product, generated_cpe);
                    printf("CPE found: '%s' \n\tfrom vendor: '%s' product: '%s'\n\n",
                        generated_cpe, pkg_terms->o_vendor, pkg_terms->o_product); // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    os_strdup(generated_cpe, pkg_terms->generated_cpe);
                    cpes_count++;
                    break;
                }

                sqlite3_finalize(stmt);
            }
            if (part) {
                break;
            }
        }
        pkg_terms = pkg_terms->prev;
    }

    if (wm_vuldet_get_min_cpe_index(db, &min_cpe_index)) {
        mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_CPE_INDEX_GET_ERROR);
        goto end;
    }

    os_calloc(1, sizeof(cpe_list), node_list);
    // Link the CPEs with its packages
    for (pkg_terms = s_terms; pkg_terms;) {
        if (pkg_terms->generated_cpe) {
            if (sqlite3_prepare_v2(db, vu_queries[VU_UPDATE_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                goto end;
            }

            sqlite3_bind_int(stmt, 1, min_cpe_index);
            sqlite3_bind_int(stmt, 2, atoi(agent->agent_id));
            sqlite3_bind_text(stmt, 3,pkg_terms->o_vendor, -1, NULL);
            sqlite3_bind_text(stmt, 4, pkg_terms->o_product, -1, NULL);
            sqlite3_bind_text(stmt, 5, pkg_terms->o_version, -1, NULL);
            sqlite3_bind_text(stmt, 6, pkg_terms->o_arch, -1, NULL);

            if (wm_vuldet_step(stmt) != SQLITE_DONE) {
                printf("Could not update the agent's CPE.\n");
                goto end;
            }
            sqlite3_finalize(stmt);

            if (wm_vuldet_add_cpe(pkg_terms->generated_cpe, node_list, min_cpe_index)) {
                printf("Could not parse '%s'.\n", pkg_terms->generated_cpe);
                goto end;
            }

            min_cpe_index--;
        }

        f_pkg_terms = pkg_terms;
        pkg_terms = pkg_terms->prev;
        wm_vuldet_free_search_terms(f_pkg_terms);
        free(f_pkg_terms);
    }

    stmt = NULL;
    if (wm_vuldet_insert_cpe_db(db, node_list, 0)) {
        goto end;
    }

    printf("******** CPEs found: %d/%d ********\n", cpes_count, pkg_count);

    s_terms = NULL;
    success = 1;
end:
    if (node_list) {
        free(node_list);
    }

    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (pkg_terms) {
        while (pkg_terms) {
            f_pkg_terms = pkg_terms;
            pkg_terms = pkg_terms->prev;
            wm_vuldet_free_search_terms(f_pkg_terms);
            free(f_pkg_terms);
        }
    }
    if (!success) {
        sqlite3_close_v2(db);
        return OS_INVALID;
    }
    return 0;
}


int wm_vuldet_update_agent_cpes(agent_software *agent, sqlite3 *db) {
    int i;
    char buffer[OS_SIZE_6144 + 1];
    size_t size;
    int sock;
    sqlite3_stmt *stmt = NULL;
    int success = 0;

    for (i = 0; i < 5 && (sock = OS_ConnectUnixDomain(WDB_LOCAL_SOCK_PATH, SOCK_STREAM, OS_SIZE_6144)) < 0; i++) {
        sleep(i);
    }

    if (i == 5) {
        return OS_INVALID;
    }

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_AGENT_CPES], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

        sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        const char *cpe_part = (const char *) sqlite3_column_text(stmt, 0);
        const char *cpe_vendor = (const char *) sqlite3_column_text(stmt, 1);
        const char *cpe_product = (const char *) sqlite3_column_text(stmt, 2);
        const char *cpe_version = (const char *) sqlite3_column_text(stmt, 3);
        const char *cpe_updatev = (const char *) sqlite3_column_text(stmt, 4);
        const char *cpe_edition = (const char *) sqlite3_column_text(stmt, 5);
        const char *cpe_language = (const char *) sqlite3_column_text(stmt, 6);
        const char *cpe_sw_edition = (const char *) sqlite3_column_text(stmt, 7);
        const char *cpe_target_sw = (const char *) sqlite3_column_text(stmt, 8);
        const char *cpe_target_hw = (const char *) sqlite3_column_text(stmt, 9);
        const char *cpe_other = (const char *) sqlite3_column_text(stmt, 10);
        const char *vendor = (const char *) sqlite3_column_text(stmt, 11);
        const char *package = (const char *) sqlite3_column_text(stmt, 12);
        const char *version = (const char *) sqlite3_column_text(stmt, 13);
        const char *arch = (const char *) sqlite3_column_text(stmt, 14);

        size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_UPDATE_CPE],
            agent->agent_id, cpe_part, cpe_vendor, cpe_product, cpe_version, cpe_updatev,
            cpe_edition, cpe_language, cpe_sw_edition, cpe_target_sw, cpe_target_hw, cpe_other,
            vendor, package, version, arch);
        if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
            close(sock);
            goto end;
        }

        // Check the wazuh-db answer
        buffer[size] = '\0';
        if (strncmp(buffer, "ok", 2)) {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_INV_WAZUHDB_RES, buffer);
            goto end;
        }
    }

    success = 1;
end:
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (!success) {
        sqlite3_close_v2(db);
        return OS_INVALID;
    }
    return 0;
}

int wm_vuldet_generate_agent_cpes(agent_software *agent) {
    sqlite3 *db;

    if (sqlite3_open_v2(CVE_DB, &db, SQLITE_OPEN_READWRITE, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, NULL);
    }

    sqlite3_exec(db, vu_queries[BEGIN_T], NULL, NULL, NULL);

    if (wm_vuldet_extract_agent_cpes(agent, db)) {
        mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_AGENT_CPE_EXT_ERROR, agent->agent_id);
        return OS_INVALID;
    }

    if (wm_vuldet_update_agent_cpes(agent, db)) {
        mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_AGENT_CPE_UPD_ERROR, agent->agent_id);
        return OS_INVALID;
    }

    sqlite3_exec(db, vu_queries[END_T], NULL, NULL, NULL);
    sqlite3_close_v2(db);
    return 0;
}

vu_search_terms * wm_vuldet_extract_search_terms(char *vendor, char *product, char *version, char *arch) {
    vu_search_terms *s_terms = NULL;
    char *vendor_found;
    int vendor_words = w_word_counter(vendor);
    int product_words = w_word_counter(product);
    int fit_product_words = 0;
    char *vendor_cpy;
    char *product_cpy;

    os_calloc(1, sizeof(vu_search_terms), s_terms);

    os_strdup(vendor, s_terms->o_vendor);
    os_strdup(vendor, vendor_cpy);
    os_strdup(product, s_terms->o_product);
    os_strdup(product, product_cpy);
    os_strdup(version, s_terms->o_version);
    os_strdup(arch, s_terms->o_arch);

    str_lowercase(vendor_cpy);
    str_lowercase(product_cpy);
    //str_lowercase(s_terms->o_version);
    //str_lowercase(s_terms->o_arch);

    os_calloc(2, sizeof(char *), s_terms->vendor_terms);
    os_calloc(3, sizeof(char *), s_terms->product_terms);
    os_strdup(vendor_cpy, *s_terms->vendor_terms);
    os_strdup(product_cpy, *s_terms->product_terms);
    wchr_replace(*s_terms->vendor_terms, ' ', '_');
    wchr_replace(*s_terms->product_terms, ' ', '_');

    // If the vendor appears inside the product, it will be taken into account separately
    if (vendor_found = strstr(product_cpy, vendor_cpy), vendor_found) {
        vendor_found += strlen(vendor_cpy);
        vendor_found += *vendor_found == ' ' ? 1 : 0;
        if (*vendor_found != '\0') {
            os_strdup(vendor_found, s_terms->product_terms[1]);
            wchr_replace(*s_terms->product_terms, ' ', '_');
            fit_product_words = w_word_counter(vendor_found);
        } else {
            vendor_found = NULL;
        }
    }

    if (vendor_words != 3) wstr_split(vendor_cpy, " ", "_", 3, &s_terms->vendor_terms);
    if (vendor_words != 2) wstr_split(vendor_cpy, " ", "_", 2, &s_terms->vendor_terms);
    if (vendor_words != 1) wstr_split(vendor_cpy, " ", "_", 1, &s_terms->vendor_terms);

    if (product_words != 4) wstr_split(product_cpy, " ", "_", 4, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 4) wstr_split(vendor_found, " ", "_", 4, &s_terms->product_terms);
    if (product_words != 3 ) wstr_split(product_cpy, " ", "_", 3, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 3) wstr_split(vendor_found, " ", "_", 3, &s_terms->product_terms);
    if (product_words != 2) wstr_split(product_cpy, " ", "_", 2, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 2) wstr_split(vendor_found, " ", "_", 2, &s_terms->product_terms);
    if (product_words != 1) wstr_split(product_cpy, " ", "_", 1, &s_terms->product_terms);

    free(vendor_cpy);
    free(product_cpy);

    return s_terms;
}

void wm_vuldet_free_search_terms(vu_search_terms *s_terms) {
    int i;
    os_free(s_terms->o_vendor);
    os_free(s_terms->o_product);
    os_free(s_terms->o_version);
    os_free(s_terms->o_arch);
    os_free(s_terms->generated_cpe)

    if (s_terms->vendor_terms) {
        for (i = 0; s_terms->vendor_terms[i]; i++) {
            os_free(s_terms->vendor_terms[i]);
        }
        os_free(s_terms->vendor_terms);
    }

    if (s_terms->product_terms) {
        for (i = 0; s_terms->product_terms[i]; i++) {
            os_free(s_terms->product_terms[i]);
        }
        os_free(s_terms->product_terms);
    }

    if (s_terms->version_terms) {
        for (i = 0; s_terms->version_terms[i]; i++) {
            os_free(s_terms->version_terms[i]);
        }
        os_free(s_terms->version_terms);
    }

    if (s_terms->arch_terms) {
        for (i = 0; s_terms->arch_terms[i]; i++) {
            os_free(s_terms->arch_terms[i]);
        }
        os_free(s_terms->arch_terms);
    }
}
