#include "../wmodules.h"
#include "wm_vuln_detector_db.h"

int wm_vuldet_nvd_cpe_parser(update_node *update, char *path, wm_vuldet_db *parsed_vulnerabilities) {
    FILE *fp;
    char buffer[OS_MAXSTR + 1];
    static char *cpe_header = "-item name=\"cpe:2.";
    size_t cpe_header_size = strlen(cpe_header);
    char *cpe_found;
    cpe_list *node_list;

    if (fp = fopen(path, "r"), !fp) {
        return OS_INVALID;
    }

    os_calloc(1, sizeof(cpe_list), node_list);
    while (fgets(buffer, OS_MAXSTR, fp)) {
        if (cpe_found = strstr(buffer, cpe_header), cpe_found) {
            char *cpe_end;
            cpe_found += cpe_header_size;
            if (cpe_found = strchr(cpe_found, ':'), cpe_found) {
                if (cpe_end = wstr_chr(++cpe_found, '"'), cpe_end) {
                    *cpe_end = '\0';
                    if (wm_vuldet_add_cpe(cpe_found, node_list, 0)) {
                        printf("Error parsing cpe line '%s'\n", buffer);
                    }
                }
            }
        }
    }

    fclose(fp);
    parsed_vulnerabilities->nvd_cpes = node_list;

    return 0;
}

int wm_vuldet_add_cpe(char *cpe_raw, cpe_list *node_list, int index) {
    cpe_node *node;
    cpe *item;

    if (item = wm_vuldet_decode_cpe(cpe_raw), !item) {
        return OS_INVALID;
    }

    item->id = index;
    os_calloc(1, sizeof(cpe_node), node);
    node->node = item;

    if(!node_list->first) {
        node_list->first = node;
    } else {
        node->prev = node_list->last;
        node_list->last->next = node;
    }

    node_list->last = node;
    return 0;
}


int wm_vuldet_insert_cpe_db(sqlite3 *db, cpe_list *node_list, char overwrite) {
    sqlite3_stmt *stmt = NULL;
    cpe_node *node_it;
    cpe *cpe_it;
    int result;
    int i;

    if (overwrite) {
        sqlite3_exec(db, vu_queries[VU_REMOVE_CPE], NULL, NULL, NULL);

        if (sqlite3_prepare_v2(db, vu_queries[VU_REMOVE_SQUENCE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }

        sqlite3_bind_text(stmt, 1, "CPE_INDEX", -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
    }


    for (i = 0, node_it = node_list->first; node_it; i++) {
        cpe_node *node_aux;
        cpe_it = node_it->node;
        if (sqlite3_prepare_v2(db, vu_queries[VU_INSERT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        if (cpe_it->id) {
            sqlite3_bind_int(stmt, 1, cpe_it->id);
        } else {
            sqlite3_bind_null(stmt, 1);
        }
        sqlite3_bind_text(stmt, 2, cpe_it->part, -1, NULL);
        sqlite3_bind_text(stmt, 3, cpe_it->vendor, -1, NULL);
        sqlite3_bind_text(stmt, 4, cpe_it->product, -1, NULL);
        sqlite3_bind_text(stmt, 5, cpe_it->version, -1, NULL);
        sqlite3_bind_text(stmt, 6, cpe_it->update, -1, NULL);
        sqlite3_bind_text(stmt, 7, cpe_it->edition, -1, NULL);
        sqlite3_bind_text(stmt, 8, cpe_it->language, -1, NULL);
        sqlite3_bind_text(stmt, 9, cpe_it->sw_edition, -1, NULL);
        sqlite3_bind_text(stmt, 10, cpe_it->target_sw, -1, NULL);
        sqlite3_bind_text(stmt, 11, cpe_it->target_hw, -1, NULL);
        sqlite3_bind_text(stmt, 12, cpe_it->other, -1, NULL);
        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
        wm_vuldet_free_cpe(cpe_it);
        free(cpe_it);
        node_aux = node_it->next;
        free(node_it);
        node_it = node_aux;
    }

    return 0;
}


char *wm_vuldet_decode_cpe_term(char *term) {
    char *decoded_term;

    term = os_strip_char(term, '\\');
    decoded_term = wstr_replace(term, "&amp;", "&");
    free(term);
    term = wstr_replace(decoded_term, "&quot;", "\"");
    free(decoded_term);

    return term;
}

cpe *wm_vuldet_decode_cpe(char *raw_cpe) {
    cpe *decoded_cpe;
    char *cpeuri;
    char *cpe_str;
    char *cpe_strnext;
    int success = 0;

    os_calloc(1, sizeof(cpe), decoded_cpe);
    os_strdup(raw_cpe, cpeuri);
    //{part}:{vendor}:{product}:{version}:{update}:{edition}:{language}:{sw_edition}:{target_sw}:{target_hw}:{other}

    if (cpe_str = wstr_chr(cpeuri, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element vendor\n");
        goto end;
    }
    *cpe_str++ = '\0';
    os_strdup(cpeuri, decoded_cpe->part);

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element product\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->vendor);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element version\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    decoded_cpe->product = wm_vuldet_decode_cpe_term(cpe_str);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element update\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    decoded_cpe->version = wm_vuldet_decode_cpe_term(cpe_str);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element edition\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->update);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element language\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->edition);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element target_sw\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->language);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        goto end; //For cpe version 2.2
        //printf("Error parsing cpe element sw_edition\n");
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->sw_edition);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element target_hw\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->target_sw);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_str == NULL) {
        printf("Error parsing cpe element other\n");
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->target_hw);
    os_strdup(cpe_strnext, decoded_cpe->other);

    success = 1;
end:
    os_free(cpeuri);
    if (!success) {
        wm_vuldet_free_cpe(decoded_cpe);
        os_free(decoded_cpe);
    }
    return decoded_cpe;
}

void wm_vuldet_free_cpe(cpe *node) {
    free(node->part);
    free(node->vendor);
    free(node->product);
    free(node->version);
    free(node->update);
    free(node->edition);
    free(node->language);
    free(node->sw_edition);
    free(node->target_sw);
    free(node->target_hw);
    free(node->other);
}
