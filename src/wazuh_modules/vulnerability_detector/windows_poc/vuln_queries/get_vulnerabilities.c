#include "../external/wazuh_tools.h"

#define NVD_DB "vuln.db"

//SQL Queries
typedef enum dict_vuln_query {
    FULL_QUERY,
    GET_DICT_CPE,
    GET_NVD_CPE,
    GET_NVD_MATCH,
    GET_NVD_MATCH_ALLV,
    GET_CONF,
} dict_vuln_query;


static const char *vuln_query[] = {
    "SELECT CPE_INDEX.VENDOR, CPE_INDEX.PRODUCT, CPE_INDEX.VERSION, NVD_CVE_MATCH.URI, NVD_CVE_CONFIGURATION.OPERATOR FROM AGENTS INNER JOIN CPE_INDEX ON AGENTS.AGENT_ID=? AND AGENTS.CPE_INDEX_ID<0 AND CPE_INDEX.ID<0 AND CPE_INDEX.ID=AGENTS.CPE_INDEX_ID INNER JOIN NVD_CPE ON NVD_CPE.VENDOR=CPE_INDEX.VENDOR AND NVD_CPE.PRODUCT=CPE_INDEX.PRODUCT AND CPE_INDEX.VERSION=NVD_CPE.VERSION INNER JOIN NVD_MATCH_CPE ON NVD_MATCH_CPE.ID_CPE=NVD_CPE.ID INNER JOIN NVD_CVE_MATCH ON NVD_CVE_MATCH.ID=NVD_MATCH_CPE.ID_MATCH INNER JOIN NVD_CVE_CONFIGURATION ON NVD_CVE_CONFIGURATION.ID=NVD_CVE_MATCH.NVD_CVE_CONFIGURATION_ID;",
    
    "SELECT CPE_INDEX.VENDOR, CPE_INDEX.PRODUCT, CPE_INDEX.VERSION FROM AGENTS INNER JOIN CPE_INDEX ON AGENTS.AGENT_ID=? AND AGENTS.CPE_INDEX_ID<0 AND CPE_INDEX.ID<0 AND CPE_INDEX.ID=AGENTS.CPE_INDEX_ID;",
    
    "SELECT NVD_CPE.ID FROM NVD_CPE WHERE NVD_CPE.VENDOR=? AND NVD_CPE.PRODUCT=? AND NVD_CPE.VERSION=?;",

    "SELECT NVD_CVE_MATCH.NVD_CVE_CONFIGURATION_ID, NVD_CVE_MATCH.URI, NVD_CVE_MATCH.VULNERABLE, NVD_CVE_MATCH.VERSION_START_INCLUDING, NVD_CVE_MATCH.VERSION_START_EXCLUDING, NVD_CVE_MATCH.VERSION_END_INCLUDING, NVD_CVE_MATCH.VERSION_END_EXCLUDING FROM NVD_MATCH_CPE INNER JOIN NVD_CVE_MATCH ON NVD_MATCH_CPE.ID_CPE = ? AND NVD_CVE_MATCH.ID = NVD_MATCH_CPE.ID_MATCH;",

    "SELECT NVD_CVE_MATCH.NVD_CVE_CONFIGURATION_ID, NVD_CVE_MATCH.URI, NVD_CVE_MATCH.VULNERABLE, NVD_CVE_MATCH.VERSION_START_INCLUDING, NVD_CVE_MATCH.VERSION_START_EXCLUDING, NVD_CVE_MATCH.VERSION_END_INCLUDING, NVD_CVE_MATCH.VERSION_END_EXCLUDING FROM NVD_MATCH_CPE INNER JOIN NVD_CVE_MATCH ON NVD_MATCH_CPE.ID_CPE = ? AND NVD_CVE_MATCH.ID = NVD_MATCH_CPE.ID_MATCH AND (NVD_CVE_MATCH.VERSION_START_INCLUDING<>'' OR NVD_CVE_MATCH.VERSION_START_EXCLUDING<>'' OR NVD_CVE_MATCH.VERSION_END_INCLUDING<>'' OR NVD_CVE_MATCH.VERSION_END_EXCLUDING);",
    
    "SELECT NVD_CVE_CONFIGURATION.NVD_CVE_ID, NVD_CVE_CONFIGURATION.OPERATOR, NVD_CVE_CONFIGURATION.PARENT, NVD_CVE.CVE_ID FROM NVD_CVE_CONFIGURATION INNER JOIN NVD_CVE ON NVD_CVE_CONFIGURATION.ID=? AND NVD_CVE_CONFIGURATION.NVD_CVE_ID=NVD_CVE.ID;"
};


int get_vuln_full_query(sqlite3 *db);
int get_vulnerabilites(sqlite3 *db, int agent_id);
int get_vuln_vpv(sqlite3 *db, char *vendor, char *product, char *version);

int main() {
    sqlite3 *db;
    sqlite3_stmt *stmt = NULL;
    int rows_full_query = 0;
    int rows_test1 = 0;
    clock_t begin;
    clock_t end;
    double time_spent;

    if (sqlite3_open_v2(NVD_DB, &db, SQLITE_OPEN_READONLY, NULL)) {
        return wm_vuldet_sql_error(db, stmt);
    }

    // begin = clock();
    // rows_full_query = get_vuln_full_query(db);
    // end = clock();
    // time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    // printf("FINISHED TEST '%d' 1Query %.4fs\n", rows_full_query, time_spent);

    begin = clock();
    rows_test1 = get_vulnerabilites(db, 2);
    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf("FINISHED TEST '%d' 4Query %.4fs\n", rows_test1, time_spent);

    sqlite3_close_v2(db);

    return 0;
}

int get_vuln_full_query(sqlite3 *db) {
    sqlite3_stmt *stmt = NULL;
    int agent_id = 2;
    int result;
    int rows = 0;
    char *vendor;
    char *product;
    char *version;
    char *uri;
    char *operator;

    if (sqlite3_prepare_v2(db, vuln_query[FULL_QUERY], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_bind_int(stmt, 1, agent_id);

    while(result = sqlite3_step(stmt), result != SQLITE_DONE) {
        switch (result) {
        case SQLITE_ROW:
            rows++;
            vendor = (char *)sqlite3_column_text(stmt, 0);
            product = (char *)sqlite3_column_text(stmt, 1);
            version = (char *)sqlite3_column_text(stmt, 2);
            uri = (char *)sqlite3_column_text(stmt, 3);
            operator = (char *)sqlite3_column_text(stmt, 4);

            printf("1Query vendor:'%s' product:'%s' version:'%s' uri:'%s' operator:'%s'\n", vendor, product, version, uri, operator);
            break;
        case SQLITE_DONE:
            printf("Query done result: '%d'\n", result);
            break;
        default:
            printf("Error in sqlite3_step '%d'\n", result);
            return -1;
        }
    }
    sqlite3_finalize(stmt);

    return rows;
}


int get_vulnerabilites(sqlite3 *db, int agent_id) {
    sqlite3_stmt *stmt = NULL;
    int result;
    int rows1 = 0;
    int rows2 = 0;
    char *vendor;
    char *product;
    char *version;

    if (sqlite3_prepare_v2(db, vuln_query[GET_DICT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_bind_int(stmt, 1, agent_id);

    while(result = sqlite3_step(stmt), result != SQLITE_DONE) {
        switch (result) {
        case SQLITE_ROW:
            vendor = (char *)sqlite3_column_text(stmt, 0);
            product = (char *)sqlite3_column_text(stmt, 1);
            version = (char *)sqlite3_column_text(stmt, 2);

            //printf("get_vulnerabilites vendor:'%s' product:'%s' version:'%s'\n", vendor, product, "*");
            //rows1 += get_vuln_vpv(db, vendor, product, version);
            rows2 += get_vuln_vpv(db, vendor, product, "*");
            break;
        case SQLITE_DONE:
            printf("Query stmt done result: '%d'\n", result);
            break;
        default:
            printf("Error stmt in sqlite3_step '%d'\n", result);
            return -1;
        }
    }
    sqlite3_finalize(stmt);

    printf("rows1: '%d' rows2: '%d'", rows1, rows2);

    return 0;
}

int get_vuln_vpv(sqlite3 *db, char *vendor, char *product, char *version) {
    sqlite3_stmt *stmt = NULL;
    sqlite3_stmt *stmt2 = NULL;
    sqlite3_stmt *stmt3 = NULL;
    int rows = 0;
    int result;
    int result2;
    int result3;
    int nvd_cpe_id;
    int nvd_cve_conf;
    int nvd_cve_id;
    int parent;
    char *uri;
    int vulnerable;
    char *operator;
    char *vsi;
    char *vse;
    char *vei;
    char *vee;
    char *cve_id;

    if (sqlite3_prepare_v2(db, vuln_query[GET_NVD_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_bind_text(stmt, 1, vendor, -1, NULL);
    sqlite3_bind_text(stmt, 2, product, -1, NULL);
    sqlite3_bind_text(stmt, 3, version, -1, NULL);

    while(result = sqlite3_step(stmt), result != SQLITE_DONE) {
        switch (result) {
        case SQLITE_ROW:
            nvd_cpe_id = sqlite3_column_int64(stmt, 0);

            //printf("GET_NVD_CPE stmt nvd_cpe_id:'%d' vendor:'%s' product:'%s' version:'%s'\n", nvd_cpe_id, vendor, product, version);

            if (sqlite3_prepare_v2(db, vuln_query[GET_NVD_MATCH_ALLV], -1, &stmt2, NULL) != SQLITE_OK) {
                return wm_vuldet_sql_error(db, stmt2);
            }
            sqlite3_bind_int(stmt2, 1, nvd_cpe_id);

            while(result2 = sqlite3_step(stmt2), result2 != SQLITE_DONE) {
                switch (result2) {
                case SQLITE_ROW:
                    nvd_cve_conf = sqlite3_column_int64(stmt2, 0);
                    uri = (char *)sqlite3_column_text(stmt2, 1);
                    vulnerable = sqlite3_column_int64(stmt2, 2);
                    vsi = (char *)sqlite3_column_text(stmt2, 3);
                    vse = (char *)sqlite3_column_text(stmt2, 4);
                    vei = (char *)sqlite3_column_text(stmt2, 5);
                    vee = (char *)sqlite3_column_text(stmt2, 6);

                    //printf("GET_NVD_MATCH stmt nvd_cve_conf:'%d' vendor:'%s' product:'%s' version:'%s' uri:'%s'\n", nvd_cve_conf, vendor, product, version, uri);

                    if (sqlite3_prepare_v2(db, vuln_query[GET_CONF], -1, &stmt3, NULL) != SQLITE_OK) {
                        return wm_vuldet_sql_error(db, stmt3);
                    }
                    sqlite3_bind_int(stmt3, 1, nvd_cve_conf);

                    while(result3 = sqlite3_step(stmt3), result3 != SQLITE_DONE) {
                        switch (result3) {
                        case SQLITE_ROW:
                            rows++;
                            nvd_cve_id = sqlite3_column_int64(stmt3, 0);
                            operator = (char *)sqlite3_column_text(stmt3, 1);
                            parent = sqlite3_column_int64(stmt3, 2);
                            cve_id = (char *)sqlite3_column_text(stmt3, 3);
                            printf("GET_CONF cve_id:'%s' vendor:'%s' product:'%s' version:'%s' operator:'%s uri:'%s' vulnerable:'%d' vsi:'%s' vse:'%s' vei:'%s' vee:'%s'\n", cve_id, vendor, product, version, operator, uri, vulnerable, vsi, vse, vei, vee);
                            break;
                        case SQLITE_DONE:
                            printf("Query stmt3 done result3: '%d'\n", result3);
                            break;
                        default:
                            printf("Error stmt3 in sqlite3_step '%d'\n", result3);
                            return -1;
                        }
                    }
                    sqlite3_finalize(stmt3);
                    break;
                case SQLITE_DONE:
                    printf("Query stmt2 done result2: '%d'\n", result2);
                    break;
                default:
                    printf("Error stmt2 in sqlite3_step '%d'\n", result2);
                    return -1;
                }
            }
            sqlite3_finalize(stmt2);
            break;
        case SQLITE_DONE:
            printf("Query stmt done result: '%d'\n", result);
            break;
        default:
            printf("Error stmt in sqlite3_step '%d'\n", result);
            return -1;
        }
    }
    sqlite3_finalize(stmt);

    return rows;
}