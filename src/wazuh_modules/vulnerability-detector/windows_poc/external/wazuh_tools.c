#include "wazuh_tools.h"

// Wazuh function
char * wstr_chr(char * str, int character) {
    char escaped = 0;

    for (;*str != '\0'; str++) {
        if (!escaped) {
            if (*str == character) {
                return str;
            }
            if (*str == '\\') {
                escaped = 1;
            }
        } else {
            escaped = 0;
        }
    }

    return NULL;
}

char *os_strip_char(const char *source, char remove)
{
    char *clean;
    const char *iterator = source;
    size_t length = 0;
    int i;

    /* Figure out how much memory to allocate */
    for ( ; *iterator; iterator++ ) {
        if ( *iterator != remove ) {
            length++;
        }
    }

    /* Allocate the memory */
    if ( (clean = (char *) malloc( length + 1 )) == NULL ) {
        // Return NULL
        return NULL;
    }
    memset(clean, '\0', length + 1);

    /* Remove the characters */
    iterator = source;
    for ( i = 0; *iterator; iterator++ ) {
        if ( *iterator != remove ) {
            clean[i] = *iterator;
            i++;
        }
    }

    return clean;
}


int wm_vuldet_create_file(const char *path, const char *source) {
    const char *ROOT = "root";
    const char *sql;
    const char *tail;
    sqlite3 *db;
    sqlite3_stmt *stmt = NULL;
    int result;

    if (sqlite3_open_v2(path, &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL)) {
        return wm_vuldet_sql_error(db, stmt);
    }

    for (sql = source; sql && *sql; sql = tail) {
        if (sqlite3_prepare_v2(db, sql, -1, &stmt, &tail) != SQLITE_OK) {
            printf("Error at sqlite3_prepare_v2 '%s'.", sql);
            return wm_vuldet_sql_error(db, stmt);
        }

        result = wm_vuldet_step(stmt);

        switch (result) {
        case SQLITE_MISUSE:
        case SQLITE_ROW:
        case SQLITE_DONE:
            break;
        default:
            printf("Error at wm_vuldet_step '%s'.", sql);
            return wm_vuldet_sql_error(db, stmt);
        }

        sqlite3_finalize(stmt);
    }

    sqlite3_close_v2(db);

    return 0;
}

int wm_vuldet_sql_error(sqlite3 *db, sqlite3_stmt *stmt) {
    printf("ERROR: wm_vuldet_sql_error: %s", sqlite3_errmsg(db));
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    sqlite3_close_v2(db);
    return OS_INVALID;
}

int wm_vuldet_step(sqlite3_stmt *stmt) {
    int attempts;
    int result;
    for (attempts = 0; (result = sqlite3_step(stmt)) == SQLITE_BUSY; attempts++) {
        if (attempts == 5) {
            return OS_INVALID;
        }
    }
    return result;
}

int wm_vuldet_get_software_info(agent_software *agent, sqlite3 *db, int agents_triag, unsigned long ignore_time) {
    int sock = 0;
    unsigned int i;
    int size;
    char buffer[OS_SIZE_6144 + 1];
    char json_str[OS_SIZE_6144 + 1];
    char scan_id[OS_SIZE_1024];
    int request = VU_SOFTWARE_REQUEST;
    char *found;
    int retval;
    sqlite3_stmt *stmt = NULL;
    cJSON *obj = NULL;
    cJSON *package_list = NULL;
    last_scan *scan;
    int result;


    for (i = 0; i < 5 && (sock = OS_ConnectUnixDomain(WDB_LOCAL_SOCK_PATH, SOCK_STREAM, OS_SIZE_6144)) < 0; i++) {
        sleep(i);
    }

    if (i == 5) {
        return OS_INVALID;
    }

    // Request the ID of the last scan
    size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_SCAN_REQUEST], agent->agent_id);
    if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
        close(sock);
        return OS_INVALID;
    }

    buffer[size] = '\0';
    if (!strncmp(buffer, "ok", 2)) {
        buffer[0] = buffer[1] = ' ';
        // Check empty answers
        if ((found = strchr(buffer, '[')) && *(++found) != '\0' && *found == ']') {
            retval = 2;
            goto end;
        }
        size = snprintf(json_str, OS_SIZE_6144, "{\"data\":%s}", buffer);
        json_str[size] = '\0';
    } else {
        retval = OS_INVALID;
        goto end;
    }

    if (obj = cJSON_Parse(json_str), obj && cJSON_IsObject(obj)) {
        cJSON_GetObjectItem(obj, "data");
    } else {
        retval = OS_INVALID;
        goto end;
    }

    size = snprintf(scan_id, OS_SIZE_1024, "%i", (int) cJSON_GetObjectItem(obj, "data")->child->child->valuedouble);
    scan_id[size] = '\0';

    cJSON_Delete(obj);
    obj = NULL;


        os_calloc(1, sizeof(last_scan), scan);
        os_strdup(scan_id, scan->last_scan_id);
        scan->last_scan_time = time(NULL);
        request = VU_SOFTWARE_FULL_REQ; // Check all at the first time

    // Request and store packages
    i = 0;
    size = snprintf(buffer, OS_SIZE_6144, vu_queries[request], agent->agent_id, scan_id, VU_MAX_PACK_REQ, i);
    if (OS_SendSecureTCP(sock, size + 1, buffer)) {
        close(sock);
        return OS_INVALID;
    }

    while (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144), size) {
        if (size > 0) {
            if (size < 10) {
                break;
            }
            buffer[size] = '\0';
            if (!strncmp(buffer, "ok", 2)) {
                buffer[0] = buffer[1] = ' ';
                size = snprintf(json_str, OS_SIZE_6144, "{\"data\":%s}", buffer);
                json_str[size] = '\0';
            } else {
                retval = OS_INVALID;
                goto end;
            }
            if (obj) {
                cJSON *new_obj;
                cJSON *data;
                if (new_obj = cJSON_Parse(json_str), !new_obj) {
                    retval = OS_INVALID;
                    goto end;
                } else if (!cJSON_IsObject(new_obj)) {
                    free(new_obj);
                    retval = OS_INVALID;
                    goto end;
                }
                data = cJSON_GetObjectItem(new_obj, "data");
                if (data) {
                    cJSON_AddItemToArray(package_list, data->child);
                    free(data->string);
                    free(data);
                }
                free(new_obj);
            } else if (obj = cJSON_Parse(json_str), obj && cJSON_IsObject(obj)) {
                package_list = cJSON_GetObjectItem(obj, "data");
                if (!package_list) {
                    retval = OS_INVALID;
                    goto end;
                }
            } else {
                retval = OS_INVALID;
                goto end;
            }

            i += VU_MAX_PACK_REQ;
            size = snprintf(buffer, OS_SIZE_6144, vu_queries[request], agent->agent_id, scan_id, VU_MAX_PACK_REQ, i);
            if (OS_SendSecureTCP(sock, size + 1, buffer)) {
                retval = OS_INVALID;
                goto end;
            }
        } else {
            retval = OS_INVALID;
            goto end;
        }
    }

    // Avoid checking the same packages again
    size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_UPDATE_SCAN], agent->agent_id, scan_id);
    if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
        retval = OS_INVALID;
        goto end;
    }

    close(sock);
    sock = 0;

    if (package_list) { // ~~~~~~~~~~~ Change on vuln
        cJSON *name;
        cJSON *version;
        cJSON *architecture;
        cJSON *vendor;

        sqlite3_exec(db, vu_queries[BEGIN_T], NULL, NULL, NULL);
        for (package_list = package_list->child; package_list; package_list = package_list->next) {
            if (sqlite3_prepare_v2(db, vu_queries[VU_INSERT_AGENTS], -1, &stmt, NULL) != SQLITE_OK) {
                close(sock);
                return wm_vuldet_sql_error(db, stmt);
            }
            if ((name = cJSON_GetObjectItem(package_list, "name")) &&
                (version = cJSON_GetObjectItem(package_list, "version")) &&
                (architecture = cJSON_GetObjectItem(package_list, "architecture")) &&
                (vendor = cJSON_GetObjectItem(package_list, "vendor"))) {

                sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);
                sqlite3_bind_text(stmt, 2, vendor->valuestring, -1, NULL);
                sqlite3_bind_text(stmt, 3, name->valuestring, -1, NULL);
                sqlite3_bind_text(stmt, 4, version->valuestring, -1, NULL);
                sqlite3_bind_text(stmt, 5, architecture->valuestring, -1, NULL);

                if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
                    close(sock);
                    return wm_vuldet_sql_error(db, stmt);
                }
            }
            sqlite3_finalize(stmt);

        }
        sqlite3_exec(db, vu_queries[END_T], NULL, NULL, NULL);
        agent->info = 1;
    } else {
    }

    retval = 0;
end:
    if (obj) {
        cJSON_Delete(obj);
    }
    if (sock) {
        close(sock);
    }
    return retval;
}

long get_fp_size(FILE * fp) {
    long offset;
    long size;

    // Get initial position

    if (offset = ftell(fp), offset < 0) {
        return -1;
    }

    // Move to end

    if (fseek(fp, 0, SEEK_END) < 0) {
        return -1;
    }

    // Get ending position

    if (size = ftell(fp), size < 0) {
        return -1;
    }

    // Restore original offset

    if (fseek(fp, offset, SEEK_SET) < 0) {
        return -1;
    }

    return size;
}

cJSON * json_fread(const char * path, char retry) {
    FILE * fp = NULL;
    cJSON * item = NULL;
    char * buffer = NULL;
    long size;
    size_t read;

    // Load file

    if (fp = fopen(path, "r"), !fp) {
        return NULL;
    }

    // Get file size

    if (size = get_fp_size(fp), size < 0) {
        goto end;
    }

    // Check file size limit

    if (size > JSON_MAX_FSIZE) {
        goto end;
    }

    // Allocate memory
    buffer = (char *)malloc(size + 1);

    // Get file and parse into JSON
    if (read = fread(buffer, 1, size, fp), read != (size_t)size && !feof(fp)) {
        goto end;
    }

    buffer[size] = '\0';

    if (item = cJSON_Parse(buffer), !item) {
        if (retry) {
            json_strip(buffer);

            if (item = cJSON_Parse(buffer), !item) {
            }
        }
    }

end:

    fclose(fp);
    free(buffer);
    return item;
}

// Clear C/C++ style comments from a JSON string
void json_strip(char * json) {
    char * line;
    char * cursor;
    char * next;

    for (line = json; line; line = next) {
        if (next = strchr(line, '\n'), next) {
            *next = '\0';
        }

        // Skip whitespaces
        cursor = line + strspn(line, " \t");

        if (!strncmp(cursor, "//", 2)) {
            if (next) {
                // If there are more lines, copy all of them
                *next = '\n';
                memmove(cursor, next, strlen(next) + 1);
                next = cursor + 1;
            } else {
                // Otherwise end string here
                *cursor = '\0';
                break;
            }
        } else if (!strncmp(cursor, "/*", 2)) {
            if (next) {
                *next = '\n';
            }

            if (next = strstr(cursor + 2, "*/"), next) {
                memmove(cursor, next + 2, strlen(next + 2) + 1);
                next = cursor;
            } else {
                // This is a syntax error - unterminated comment
                break;
            }
        } else if (next) {
            // Restore newline and move forward
            *next++ = '\n';
        }
    }
}

// Request download
int wurl_request(const char * url, const char * dest) {
    const char * COMMAND = "download";
    char response[64];
    char * _url;
    char * srequest;
    size_t zrequest;
    ssize_t zrecv;
    int sock;
    int retval = -1;

    if (!url) {
        return -1;
    }

    // Escape whitespaces

    _url = wstr_replace(url, " ", "%20");

    // Build request

    zrequest = strlen(_url) + strlen(dest) + strlen(COMMAND) + 3;
    os_malloc(zrequest, srequest);
    snprintf(srequest, zrequest, "%s %s %s", COMMAND, _url, dest);

    // Connect to downlod module

    if (sock = OS_ConnectUnixDomain(WM_DOWNLOAD_SOCK_PATH, SOCK_STREAM, OS_MAXSTR), sock < 0) {
        goto end;
    }

    // Send request

    if (send(sock, srequest, zrequest - 1, 0) != (ssize_t)(zrequest - 1)) {
        goto end;
    }

    // Receive response

    switch (zrecv = recv(sock, response, sizeof(response) - 1, 0), zrecv) {
    case -1:
        goto end;

    case 0:
        goto end;

    default:
        response[zrecv] = '\0';

        // Parse responses

        if (!strcmp(response, "ok")) {
            retval = 0;
        } else if (!strcmp(response, "err connecting to url")) {
            retval = OS_CONNERR;
        } else if (!strcmp(response, "err writing file")) {
            retval = OS_FILERR;
        } else {
        }
    }

end:
    free(_url);
    free(srequest);

    if (sock >= 0) {
        close(sock);
    }

    return retval;
}

// Replace substrings
char * wstr_replace(const char * string, const char * search, const char * replace) {
    char * result;
    const char * scur;
    const char * snext;
    size_t wi = 0;
    size_t zcur;

    if (!(string && search && replace)) {
        return NULL;
    }

    const size_t ZSEARCH = strlen(search);
    const size_t ZREPLACE = strlen(replace);

    os_malloc(sizeof(char), result);

    for (scur = string; snext = strstr(scur, search), snext; scur = snext + ZSEARCH) {
        zcur = snext - scur;
        os_realloc(result, wi + zcur + ZREPLACE + 1, result);
        memcpy(result + wi, scur, zcur);
        wi += zcur;
        memcpy(result + wi, replace, ZREPLACE);
        wi += ZREPLACE;
    }

    // Copy last chunk

    zcur = strlen(scur);
    os_realloc(result, wi + zcur + 1, result);
    memcpy(result + wi, scur, zcur);
    wi += zcur;

    result[wi] = '\0';
    return result;
}
