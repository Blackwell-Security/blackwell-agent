#include "wazuh_tools.h"

// Wazuh function
char * wstr_chr(char * str, int character) {
    char escaped = 0;

    for (;*str != '\0'; str++) {
        if (!escaped) {
            if (*str == character) {
                return str;
            }
            if (*str == '\\') {
                escaped = 1;
            }
        } else {
            escaped = 0;
        }
    }

    return NULL;
}

char *os_strip_char(const char *source, char remove)
{
    char *clean;
    const char *iterator = source;
    size_t length = 0;
    int i;

    /* Figure out how much memory to allocate */
    for ( ; *iterator; iterator++ ) {
        if ( *iterator != remove ) {
            length++;
        }
    }

    /* Allocate the memory */
    if ( (clean = (char *) malloc( length + 1 )) == NULL ) {
        // Return NULL
        return NULL;
    }
    memset(clean, '\0', length + 1);

    /* Remove the characters */
    iterator = source;
    for ( i = 0; *iterator; iterator++ ) {
        if ( *iterator != remove ) {
            clean[i] = *iterator;
            i++;
        }
    }

    return clean;
}


int wm_vuldet_create_file(const char *path, const char *source) {
    const char *ROOT = "root";
    const char *sql;
    const char *tail;
    sqlite3 *db;
    sqlite3_stmt *stmt = NULL;
    int result;

    if (sqlite3_open_v2(path, &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL)) {
        return wm_vuldet_sql_error(db, stmt);
    }

    for (sql = source; sql && *sql; sql = tail) {
        if (sqlite3_prepare_v2(db, sql, -1, &stmt, &tail) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }

        result = wm_vuldet_step(stmt);

        switch (result) {
        case SQLITE_MISUSE:
        case SQLITE_ROW:
        case SQLITE_DONE:
            break;
        default:
            printf("Could not create the DB.");
            return wm_vuldet_sql_error(db, stmt);
        }

        sqlite3_finalize(stmt);
    }

    sqlite3_close_v2(db);

    return 0;
}

int wm_vuldet_sql_error(sqlite3 *db, sqlite3_stmt *stmt) {
    printf("ERROR: wm_vuldet_sql_error: %s", sqlite3_errmsg(db));
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    sqlite3_close_v2(db);
    return OS_INVALID;
}

int wm_vuldet_step(sqlite3_stmt *stmt) {
    int attempts;
    int result;
    for (attempts = 0; (result = sqlite3_step(stmt)) == SQLITE_BUSY; attempts++) {
        if (attempts == 5) {
            return OS_INVALID;
        }
    }
    return result;
}

int wm_vuldet_get_software_info(agent_software *agent, sqlite3 *db, int agents_triag, unsigned long ignore_time) {
    int sock = 0;
    unsigned int i;
    int size;
    char buffer[OS_SIZE_6144 + 1];
    char json_str[OS_SIZE_6144 + 1];
    char scan_id[OS_SIZE_1024];
    int request = VU_SOFTWARE_REQUEST;
    char *found;
    int retval;
    sqlite3_stmt *stmt = NULL;
    cJSON *obj = NULL;
    cJSON *package_list = NULL;
    last_scan *scan;
    int result;


    for (i = 0; i < 5 && (sock = OS_ConnectUnixDomain(WDB_LOCAL_SOCK_PATH, SOCK_STREAM, OS_SIZE_6144)) < 0; i++) {
        sleep(i);
    }

    if (i == 5) {
        return OS_INVALID;
    }

    // Request the ID of the last scan
    size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_SCAN_REQUEST], agent->agent_id);
    if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
        close(sock);
        return OS_INVALID;
    }

    buffer[size] = '\0';
    if (!strncmp(buffer, "ok", 2)) {
        buffer[0] = buffer[1] = ' ';
        // Check empty answers
        if ((found = strchr(buffer, '[')) && *(++found) != '\0' && *found == ']') {
            retval = 2;
            goto end;
        }
        size = snprintf(json_str, OS_SIZE_6144, "{\"data\":%s}", buffer);
        json_str[size] = '\0';
    } else {
        retval = OS_INVALID;
        goto end;
    }

    if (obj = cJSON_Parse(json_str), obj && cJSON_IsObject(obj)) {
        cJSON_GetObjectItem(obj, "data");
    } else {
        retval = OS_INVALID;
        goto end;
    }

    size = snprintf(scan_id, OS_SIZE_1024, "%i", (int) cJSON_GetObjectItem(obj, "data")->child->child->valuedouble);
    scan_id[size] = '\0';

    cJSON_Delete(obj);
    obj = NULL;


        os_calloc(1, sizeof(last_scan), scan);
        os_strdup(scan_id, scan->last_scan_id);
        scan->last_scan_time = time(NULL);
        request = VU_SOFTWARE_FULL_REQ; // Check all at the first time

    // Request and store packages
    i = 0;
    size = snprintf(buffer, OS_SIZE_6144, vu_queries[request], agent->agent_id, scan_id, VU_MAX_PACK_REQ, i);
    if (OS_SendSecureTCP(sock, size + 1, buffer)) {
        close(sock);
        return OS_INVALID;
    }

    while (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144), size) {
        if (size > 0) {
            if (size < 10) {
                break;
            }
            buffer[size] = '\0';
            if (!strncmp(buffer, "ok", 2)) {
                buffer[0] = buffer[1] = ' ';
                size = snprintf(json_str, OS_SIZE_6144, "{\"data\":%s}", buffer);
                json_str[size] = '\0';
            } else {
                retval = OS_INVALID;
                goto end;
            }
            if (obj) {
                cJSON *new_obj;
                cJSON *data;
                if (new_obj = cJSON_Parse(json_str), !new_obj) {
                    retval = OS_INVALID;
                    goto end;
                } else if (!cJSON_IsObject(new_obj)) {
                    free(new_obj);
                    retval = OS_INVALID;
                    goto end;
                }
                data = cJSON_GetObjectItem(new_obj, "data");
                if (data) {
                    cJSON_AddItemToArray(package_list, data->child);
                    free(data->string);
                    free(data);
                }
                free(new_obj);
            } else if (obj = cJSON_Parse(json_str), obj && cJSON_IsObject(obj)) {
                package_list = cJSON_GetObjectItem(obj, "data");
                if (!package_list) {
                    retval = OS_INVALID;
                    goto end;
                }
            } else {
                retval = OS_INVALID;
                goto end;
            }

            i += VU_MAX_PACK_REQ;
            size = snprintf(buffer, OS_SIZE_6144, vu_queries[request], agent->agent_id, scan_id, VU_MAX_PACK_REQ, i);
            if (OS_SendSecureTCP(sock, size + 1, buffer)) {
                retval = OS_INVALID;
                goto end;
            }
        } else {
            retval = OS_INVALID;
            goto end;
        }
    }

    // Avoid checking the same packages again
    size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_UPDATE_SCAN], agent->agent_id, scan_id);
    if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
        retval = OS_INVALID;
        goto end;
    }

    close(sock);
    sock = 0;

    if (package_list) { // ~~~~~~~~~~~ Change on vuln
        cJSON *name;
        cJSON *version;
        cJSON *architecture;
        cJSON *vendor;

        sqlite3_exec(db, vu_queries[BEGIN_T], NULL, NULL, NULL);
        for (package_list = package_list->child; package_list; package_list = package_list->next) {
            if (sqlite3_prepare_v2(db, vu_queries[VU_INSERT_AGENTS], -1, &stmt, NULL) != SQLITE_OK) {
                close(sock);
                return wm_vuldet_sql_error(db, stmt);
            }
            if ((name = cJSON_GetObjectItem(package_list, "name")) &&
                (version = cJSON_GetObjectItem(package_list, "version")) &&
                (architecture = cJSON_GetObjectItem(package_list, "architecture")) &&
                (vendor = cJSON_GetObjectItem(package_list, "vendor"))) {

                sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);
                sqlite3_bind_text(stmt, 2, vendor->valuestring, -1, NULL);
                sqlite3_bind_text(stmt, 3, name->valuestring, -1, NULL);
                sqlite3_bind_text(stmt, 4, version->valuestring, -1, NULL);
                sqlite3_bind_text(stmt, 5, architecture->valuestring, -1, NULL);

                if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
                    close(sock);
                    return wm_vuldet_sql_error(db, stmt);
                }
            }
            sqlite3_finalize(stmt);

        }
        sqlite3_exec(db, vu_queries[END_T], NULL, NULL, NULL);
        agent->info = 1;
    } else {
    }

    retval = 0;
end:
    if (obj) {
        cJSON_Delete(obj);
    }
    if (sock) {
        close(sock);
    }
    return retval;
}
