#include "../external/wazuh_tools.h"

#define wchr_replace(x, y, z) { char *x_it; for (x_it = x; *x_it != '\0'; x_it++) if (*x_it == y) *x_it = z; } // Add to string_op.h

#define w_word_counter(x) ({ int w_count = 0; char *w_it = x; \
    while (*w_it) { if (*w_it != ' ') { w_count++; while (*w_it != ' ' && *w_it != '\0') w_it++; continue;} w_it++;} w_count;}) // Add to string_op.h

typedef struct vu_search_terms {
    char *o_vendor;
    char *o_product;
    char *o_version;
    char *o_arch;
    char **vendor_terms;
    char **product_terms;
    char **version_terms;
    char **arch_terms;
    struct vu_search_terms *next;
    struct vu_search_terms *prev;
} vu_search_terms;

/* Split a string within splitted_str
    - delim: Words delimiter
    - occurrences: Words by division
    - replace_delim: (Optional) Replace the delimiter with a new one
*/
void wstr_split(char *str, char *delim, char *replace_delim, int occurrences, char ***splitted_str);
vu_search_terms * extract_search_terms(char *vendor, char *product, char *version, char *arch);
void free_search_terms(vu_search_terms *s_terms);
int extract_agent_cpes(agent_software *agent, sqlite3 *db);

void wstr_split(char *str, char *delim, char *replace_delim, int occurrences, char ***splitted_str) { // Add to string_op.c
    char *new_delim = replace_delim ? replace_delim : delim;
    size_t new_delim_size = strlen(replace_delim ? replace_delim : delim);
    int count = 0;
    int splitted_count;
    char *str_cpy, *str_cpy_ref;
    char *str_it;
    char **acc_strs;

    if (occurrences < 1) {
        return;
    }

    os_strdup(str, str_cpy);
    str_cpy_ref = str_cpy;
    str_it = strtok(str_cpy, delim);

    os_calloc(occurrences, sizeof(char *), acc_strs);

    for (splitted_count = 0; *splitted_str && (*splitted_str)[splitted_count]; splitted_count++);

    for (; str_it && *str_it; count++) {
        os_strdup(str_it, acc_strs[count]);

        if (count == occurrences - 1) {
            // Add a new term
            size_t term_size;
            char *new_term_it;

            for (count = term_size = 0; count < occurrences; count++) {
                term_size += strlen(acc_strs[count]);
            }

            term_size += (occurrences - 1) * new_delim_size + 1;

            os_realloc(*splitted_str, (splitted_count + 2) * sizeof(char *), *splitted_str);
            os_calloc(term_size, sizeof(char), (*splitted_str)[splitted_count]);
            (*splitted_str)[splitted_count + 1] = NULL;

            for (count = 0, new_term_it = (*splitted_str)[splitted_count]; count < occurrences; count++) {
                if (count) {
                    strncpy(new_term_it, new_delim, new_delim_size);
                    new_term_it += new_delim_size;
                }
                strncpy(new_term_it, acc_strs[count], strlen(acc_strs[count]));
                new_term_it += strlen(acc_strs[count]);
                os_free(acc_strs[count]);
            }

            splitted_count++;
            count = -1;
        }
        str_it = strtok(NULL, delim);
    }

    // Remove residual terms (they are discarded)
    for (count = 0; acc_strs[count]; count++) {
        free(acc_strs[count]);
    }
    free(acc_strs);
    free(str_cpy_ref);
}

vu_search_terms * extract_search_terms(char *vendor, char *product, char *version, char *arch) {
    vu_search_terms *s_terms = NULL;
    char *vendor_found;
    int vendor_words = w_word_counter(vendor);
    int product_words = w_word_counter(product);
    int fit_product_words = 0;

    os_calloc(1, sizeof(vu_search_terms), s_terms);

    os_strdup(vendor, s_terms->o_vendor);
    os_strdup(product, s_terms->o_product);
    os_strdup(version, s_terms->o_version);
    os_strdup(arch, s_terms->o_arch);

    str_lowercase(s_terms->o_vendor);
    str_lowercase(s_terms->o_product);
    str_lowercase(s_terms->o_version);
    str_lowercase(s_terms->o_arch);

    os_calloc(2, sizeof(char *), s_terms->vendor_terms);
    os_calloc(3, sizeof(char *), s_terms->product_terms);
    os_strdup(s_terms->o_vendor, *s_terms->vendor_terms);
    os_strdup(s_terms->o_product, *s_terms->product_terms);
    wchr_replace(*s_terms->vendor_terms, ' ', '_');
    wchr_replace(*s_terms->product_terms, ' ', '_');

    // If the vendor appears inside the product, it will be taken into account separately
    if (vendor_found = strstr(s_terms->o_product, s_terms->o_vendor), vendor_found) {
        vendor_found += strlen(s_terms->o_vendor);
        vendor_found += *vendor_found == ' ' ? 1 : 0;
        if (*vendor_found != '\0') {
            os_strdup(vendor_found, s_terms->product_terms[1]);
            wchr_replace(*s_terms->product_terms, ' ', '_');
            fit_product_words = w_word_counter(vendor_found);
        } else {
            vendor_found = NULL;
        }
    }

    if (vendor_words != 3) wstr_split(s_terms->o_vendor, " ", "_", 3, &s_terms->vendor_terms);
    if (vendor_words != 2) wstr_split(s_terms->o_vendor, " ", "_", 2, &s_terms->vendor_terms);
    if (vendor_words != 1) wstr_split(s_terms->o_vendor, " ", "_", 1, &s_terms->vendor_terms);

    if (product_words != 4) wstr_split(s_terms->o_product, " ", "_", 4, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 4) wstr_split(vendor_found, " ", "_", 4, &s_terms->product_terms);
    if (product_words != 3 ) wstr_split(s_terms->o_product, " ", "_", 3, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 3) wstr_split(vendor_found, " ", "_", 3, &s_terms->product_terms);
    if (product_words != 2) wstr_split(s_terms->o_product, " ", "_", 2, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 2) wstr_split(vendor_found, " ", "_", 2, &s_terms->product_terms);
    if (product_words != 1) wstr_split(s_terms->o_product, " ", "_", 1, &s_terms->product_terms);

    return s_terms;
}

void free_search_terms(vu_search_terms *s_terms) {
    int i;
    os_free(s_terms->o_vendor);
    os_free(s_terms->o_product);
    os_free(s_terms->o_version);
    os_free(s_terms->o_arch);

    if (s_terms->vendor_terms) {
        for (i = 0; s_terms->vendor_terms[i]; i++) {
            os_free(s_terms->vendor_terms[i]);
        }
    }

    if (s_terms->product_terms) {
        for (i = 0; s_terms->product_terms[i]; i++) {
            os_free(s_terms->product_terms[i]);
        }
    }

    if (s_terms->version_terms) {
        for (i = 0; s_terms->version_terms[i]; i++) {
            os_free(s_terms->version_terms[i]);
        }
    }

    if (s_terms->arch_terms) {
        for (i = 0; s_terms->arch_terms[i]; i++) {
            os_free(s_terms->arch_terms[i]);
        }
    }
}



int extract_agent_cpes(agent_software *agent, sqlite3 *db) {
    sqlite3_stmt *stmt = NULL;
    int result;
    vu_search_terms *s_terms = NULL;
    vu_search_terms *pkg_terms;
    int pkg_count, cpes_count;

    // If it is a Windows agent ~~~~~~~~~

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_PACK_WITHOUT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        char *vendor = (char *) sqlite3_column_text(stmt, 0);
        char *product = (char *) sqlite3_column_text(stmt, 1);
        char *version = (char *) sqlite3_column_text(stmt, 2);
        char *arch = (char *) sqlite3_column_text(stmt, 3);

        if (pkg_terms = extract_search_terms(vendor, product, version, arch), !pkg_terms) {
            printf("Could not generate the search terms for %s:%s:%s:%s in the agent %s.", vendor, product, version, arch, agent->agent_id);
            continue;
        }

        if (s_terms) {
            s_terms->next = pkg_terms;
            pkg_terms->prev = s_terms;
        }
        s_terms = pkg_terms;
    }
    sqlite3_finalize(stmt);

    // Use the search terms to find a valid CPE for each package
    for (pkg_count = 0, cpes_count = 0, pkg_terms = s_terms; pkg_terms;) {
        int v_index, p_index;
        pkg_count++;
        for (v_index = 0; pkg_terms->vendor_terms[v_index]; v_index++) {
            char *part = NULL;
            for (p_index = 0; pkg_terms->product_terms[p_index]; p_index++) {
                if (sqlite3_prepare_v2(db, vu_queries[VU_SEARCH_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                    return wm_vuldet_sql_error(db, stmt);
                }

                sqlite3_bind_text(stmt, 1, pkg_terms->vendor_terms[v_index], -1, NULL);
                sqlite3_bind_text(stmt, 2, pkg_terms->product_terms[p_index], -1, NULL);

                if (wm_vuldet_step(stmt) == SQLITE_ROW) {
                    part = (char *) sqlite3_column_text(stmt, 0);
                    printf("CPE found: '%c:%s:%s:%s:*:*:*:*:*:%s:*' \n\tfrom vendor: '%s' product: '%s'\n\n",
                        *part, pkg_terms->vendor_terms[v_index], pkg_terms->product_terms[p_index],
                        pkg_terms->o_version, pkg_terms->o_arch, pkg_terms->o_vendor, pkg_terms->o_product);
                    sqlite3_finalize(stmt);
                    cpes_count++;
                    break;
                }

                sqlite3_finalize(stmt);
            }
            if (part) {
                break;
            }
        }

        free_search_terms(pkg_terms);
        if (!pkg_terms->prev) {
            os_free(pkg_terms);
        } else {
            pkg_terms = pkg_terms->prev;
            free(pkg_terms->next);
        }
    }
    printf("******** CPEs found: %d/%d ********\n", cpes_count, pkg_count);


    return 0;
}

int main() {
    agent_software *agent;
    sqlite3 *db;

    os_calloc(1, sizeof(agent_software), agent);
    agent->agent_id = strdup("003");

    if (sqlite3_open_v2(CPE_DB, &db, SQLITE_OPEN_READWRITE, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, NULL);
    }

    if (wm_vuldet_get_software_info(agent, db, -47, -47)) {
        printf("ERROR: Could not get the agent package list.");
        return 1;
    }

    if (extract_agent_cpes(agent, db)) {
        printf("ERROR: Could not get the agent CPE list.");
        return 1;
    }

    return 0;
}
