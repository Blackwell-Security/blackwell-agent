#include "../external/wazuh_tools.h"

#define wchr_replace(x, y, z) { char *x_it; for (x_it = x; *x_it != '\0'; x_it++) if (*x_it == y) *x_it = z; } // Add to string_op.h

#define w_word_counter(x) ({ int w_count = 0; char *w_it = x; \
    while (*w_it) { if (*w_it != ' ') { w_count++; while (*w_it != ' ' && *w_it != '\0') w_it++; continue;} w_it++;} w_count;}) // Add to string_op.h

typedef struct vu_search_terms {
    char *generated_cpe;
    char *o_vendor;
    char *o_product;
    char *o_version;
    char *o_arch;
    char **vendor_terms;
    char **product_terms;
    char **version_terms;
    char **arch_terms;
    struct vu_search_terms *next;
    struct vu_search_terms *prev;
} vu_search_terms;

/* Split a string within splitted_str
    - delim: Words delimiter
    - occurrences: Words by division
    - replace_delim: (Optional) Replace the delimiter with a new one
*/
void wstr_split(char *str, char *delim, char *replace_delim, int occurrences, char ***splitted_str);
vu_search_terms * extract_search_terms(char *vendor, char *product, char *version, char *arch);
void free_search_terms(vu_search_terms *s_terms);
int extract_agent_cpes(agent_software *agent, sqlite3 *db);
int update_agent_cpes(agent_software *agent, sqlite3 *db);

void wstr_split(char *str, char *delim, char *replace_delim, int occurrences, char ***splitted_str) { // Add to string_op.c
    char *new_delim = replace_delim ? replace_delim : delim;
    size_t new_delim_size = strlen(replace_delim ? replace_delim : delim);
    int count = 0;
    int splitted_count;
    char *str_cpy, *str_cpy_ref;
    char *str_it;
    char **acc_strs;

    if (occurrences < 1) {
        return;
    }

    os_strdup(str, str_cpy);
    str_cpy_ref = str_cpy;
    str_it = strtok(str_cpy, delim);

    os_calloc(occurrences, sizeof(char *), acc_strs);

    for (splitted_count = 0; *splitted_str && (*splitted_str)[splitted_count]; splitted_count++);

    for (; str_it && *str_it; count++) {
        os_strdup(str_it, acc_strs[count]);

        if (count == occurrences - 1) {
            // Add a new term
            size_t term_size;
            char *new_term_it;

            for (count = term_size = 0; count < occurrences; count++) {
                term_size += strlen(acc_strs[count]);
            }

            term_size += (occurrences - 1) * new_delim_size + 1;

            os_realloc(*splitted_str, (splitted_count + 2) * sizeof(char *), *splitted_str);
            os_calloc(term_size, sizeof(char), (*splitted_str)[splitted_count]);
            (*splitted_str)[splitted_count + 1] = NULL;

            for (count = 0, new_term_it = (*splitted_str)[splitted_count]; count < occurrences; count++) {
                if (count) {
                    strncpy(new_term_it, new_delim, new_delim_size);
                    new_term_it += new_delim_size;
                }
                strncpy(new_term_it, acc_strs[count], strlen(acc_strs[count]));
                new_term_it += strlen(acc_strs[count]);
                os_free(acc_strs[count]);
            }

            splitted_count++;
            count = -1;
        }
        str_it = strtok(NULL, delim);
    }

    // Remove residual terms (they are discarded)
    for (count = 0; acc_strs[count]; count++) {
        free(acc_strs[count]);
    }
    free(acc_strs);
    free(str_cpy_ref);
}

vu_search_terms * extract_search_terms(char *vendor, char *product, char *version, char *arch) {
    vu_search_terms *s_terms = NULL;
    char *vendor_found;
    int vendor_words = w_word_counter(vendor);
    int product_words = w_word_counter(product);
    int fit_product_words = 0;
    char *vendor_cpy;
    char *product_cpy;

    os_calloc(1, sizeof(vu_search_terms), s_terms);

    os_strdup(vendor, s_terms->o_vendor);
    os_strdup(vendor, vendor_cpy);
    os_strdup(product, s_terms->o_product);
    os_strdup(product, product_cpy);
    os_strdup(version, s_terms->o_version);
    os_strdup(arch, s_terms->o_arch);

    str_lowercase(vendor_cpy);
    str_lowercase(product_cpy);
    //str_lowercase(s_terms->o_version);
    //str_lowercase(s_terms->o_arch);

    os_calloc(2, sizeof(char *), s_terms->vendor_terms);
    os_calloc(3, sizeof(char *), s_terms->product_terms);
    os_strdup(vendor_cpy, *s_terms->vendor_terms);
    os_strdup(product_cpy, *s_terms->product_terms);
    wchr_replace(*s_terms->vendor_terms, ' ', '_');
    wchr_replace(*s_terms->product_terms, ' ', '_');

    // If the vendor appears inside the product, it will be taken into account separately
    if (vendor_found = strstr(product_cpy, vendor_cpy), vendor_found) {
        vendor_found += strlen(vendor_cpy);
        vendor_found += *vendor_found == ' ' ? 1 : 0;
        if (*vendor_found != '\0') {
            os_strdup(vendor_found, s_terms->product_terms[1]);
            wchr_replace(*s_terms->product_terms, ' ', '_');
            fit_product_words = w_word_counter(vendor_found);
        } else {
            vendor_found = NULL;
        }
    }

    if (vendor_words != 3) wstr_split(vendor_cpy, " ", "_", 3, &s_terms->vendor_terms);
    if (vendor_words != 2) wstr_split(vendor_cpy, " ", "_", 2, &s_terms->vendor_terms);
    if (vendor_words != 1) wstr_split(vendor_cpy, " ", "_", 1, &s_terms->vendor_terms);

    if (product_words != 4) wstr_split(product_cpy, " ", "_", 4, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 4) wstr_split(vendor_found, " ", "_", 4, &s_terms->product_terms);
    if (product_words != 3 ) wstr_split(product_cpy, " ", "_", 3, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 3) wstr_split(vendor_found, " ", "_", 3, &s_terms->product_terms);
    if (product_words != 2) wstr_split(product_cpy, " ", "_", 2, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 2) wstr_split(vendor_found, " ", "_", 2, &s_terms->product_terms);
    if (product_words != 1) wstr_split(product_cpy, " ", "_", 1, &s_terms->product_terms);

    free(vendor_cpy);
    free(product_cpy);

    return s_terms;
}

void free_search_terms(vu_search_terms *s_terms) {
    int i;
    os_free(s_terms->o_vendor);
    os_free(s_terms->o_product);
    os_free(s_terms->o_version);
    os_free(s_terms->o_arch);
    os_free(s_terms->generated_cpe)

    if (s_terms->vendor_terms) {
        for (i = 0; s_terms->vendor_terms[i]; i++) {
            os_free(s_terms->vendor_terms[i]);
        }
        os_free(s_terms->vendor_terms);
    }

    if (s_terms->product_terms) {
        for (i = 0; s_terms->product_terms[i]; i++) {
            os_free(s_terms->product_terms[i]);
        }
        os_free(s_terms->product_terms);
    }

    if (s_terms->version_terms) {
        for (i = 0; s_terms->version_terms[i]; i++) {
            os_free(s_terms->version_terms[i]);
        }
        os_free(s_terms->version_terms);
    }

    if (s_terms->arch_terms) {
        for (i = 0; s_terms->arch_terms[i]; i++) {
            os_free(s_terms->arch_terms[i]);
        }
        os_free(s_terms->arch_terms);
    }
}

int update_agent_cpes(agent_software *agent, sqlite3 *db) {
    int i;
    char buffer[OS_SIZE_6144 + 1];
    size_t size;
    int sock;
    sqlite3_stmt *stmt = NULL;
    int success = 0;

    for (i = 0; i < 5 && (sock = OS_ConnectUnixDomain(WDB_LOCAL_SOCK_PATH, SOCK_STREAM, OS_SIZE_6144)) < 0; i++) {
        sleep(i);
    }

    if (i == 5) {
        return OS_INVALID;
    }

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_AGENT_CPES], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

        sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        const char *cpe_part = sqlite3_column_text(stmt, 0);
        const char *cpe_vendor = sqlite3_column_text(stmt, 1);
        const char *cpe_product = sqlite3_column_text(stmt, 2);
        const char *cpe_version = sqlite3_column_text(stmt, 3);
        const char *cpe_updatev = sqlite3_column_text(stmt, 4);
        const char *cpe_edition = sqlite3_column_text(stmt, 5);
        const char *cpe_language = sqlite3_column_text(stmt, 6);
        const char *cpe_sw_edition = sqlite3_column_text(stmt, 7);
        const char *cpe_target_sw = sqlite3_column_text(stmt, 8);
        const char *cpe_target_hw = sqlite3_column_text(stmt, 9);
        const char *cpe_other = sqlite3_column_text(stmt, 10);
        const char *vendor = sqlite3_column_text(stmt, 11);
        const char *package = sqlite3_column_text(stmt, 12);
        const char *version = sqlite3_column_text(stmt, 13);
        const char *arch = sqlite3_column_text(stmt, 14);

        size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_UPDATE_CPE],
            agent->agent_id, cpe_part, cpe_vendor, cpe_product, cpe_version, cpe_updatev,
            cpe_edition, cpe_language, cpe_sw_edition, cpe_target_sw, cpe_target_hw, cpe_other,
            vendor, package, version, arch);
        if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
            close(sock);
            return OS_INVALID;
        }

        // Check the wazuh-db answer
        buffer[size] = '\0';
        if (strncmp(buffer, "ok", 2)) {
            goto end;
        }
    }
    sqlite3_finalize(stmt);

    stmt = NULL;
    success = 1;
end:
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (success) {
        return 0;
    } else {
        return 1;
    }
}

int extract_agent_cpes(agent_software *agent, sqlite3 *db) {
    sqlite3_stmt *stmt = NULL;
    int result;
    vu_search_terms *s_terms = NULL;
    vu_search_terms *pkg_terms;
    int pkg_count, cpes_count;
    char generated_cpe[OS_SIZE_128 + 1];
    int min_cpe_index;
    int success = 0;
    vu_search_terms *f_pkg_terms;
    cpe_list *node_list = NULL;

    // If it is a Windows agent ~~~~~~~~~

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_PACK_WITHOUT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        char *vendor = (char *) sqlite3_column_text(stmt, 0);
        char *product = (char *) sqlite3_column_text(stmt, 1);
        char *version = (char *) sqlite3_column_text(stmt, 2);
        char *arch = (char *) sqlite3_column_text(stmt, 3);

        if (pkg_terms = extract_search_terms(vendor, product, version, arch), !pkg_terms) {
            printf("Could not generate the search terms for %s:%s:%s:%s in the agent %s.", vendor, product, version, arch, agent->agent_id);
            continue;
        }

        if (s_terms) {
            s_terms->next = pkg_terms;
            pkg_terms->prev = s_terms;
        }
        s_terms = pkg_terms;
    }
    sqlite3_finalize(stmt);

    // Use the search terms to find a valid CPE for each package
    for (pkg_count = 0, cpes_count = 0, pkg_terms = s_terms; pkg_terms;) {
        int v_index, p_index;
        pkg_count++;
        for (v_index = 0; pkg_terms->vendor_terms[v_index]; v_index++) {
            char *part = NULL;
            for (p_index = 0; pkg_terms->product_terms[p_index]; p_index++) {
                if (sqlite3_prepare_v2(db, vu_queries[VU_SEARCH_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                    return wm_vuldet_sql_error(db, stmt);
                }

                sqlite3_bind_text(stmt, 1, pkg_terms->vendor_terms[v_index], -1, NULL);
                sqlite3_bind_text(stmt, 2, pkg_terms->product_terms[p_index], -1, NULL);

                if (wm_vuldet_step(stmt) == SQLITE_ROW) {
                    part = (char *) sqlite3_column_text(stmt, 0);
                    snprintf(generated_cpe, OS_SIZE_128, "%c:%s:%s:%s:*:*:*:*:*:%s:*", *part,
                        pkg_terms->vendor_terms[v_index], pkg_terms->product_terms[p_index],
                        pkg_terms->o_version, pkg_terms->o_arch);
                    str_lowercase(generated_cpe);
                    sqlite3_finalize(stmt);
                    printf("CPE found: '%s' \n\tfrom vendor: '%s' product: '%s'\n\n",
                        generated_cpe, pkg_terms->o_vendor, pkg_terms->o_product);
                    os_strdup(generated_cpe, pkg_terms->generated_cpe);
                    cpes_count++;
                    break;
                }

                sqlite3_finalize(stmt);
            }
            if (part) {
                break;
            }
        }
        pkg_terms = pkg_terms->prev;
    }

    if (get_min_cpe_index(db, &min_cpe_index)) {
        printf("Could not get the lower CPE index.\n");
        goto end;
    }

    os_calloc(1, sizeof(cpe_list), node_list);
    // Link the CPEs with its packages
    for (pkg_terms = s_terms; pkg_terms;) {
        if (pkg_terms->generated_cpe) {
            if (sqlite3_prepare_v2(db, vu_queries[VU_UPDATE_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                return wm_vuldet_sql_error(db, stmt);
            }

            sqlite3_bind_int(stmt, 1, min_cpe_index);
            sqlite3_bind_int(stmt, 2, atoi(agent->agent_id));
            sqlite3_bind_text(stmt, 3,pkg_terms->o_vendor, -1, NULL);
            sqlite3_bind_text(stmt, 4, pkg_terms->o_product, -1, NULL);
            sqlite3_bind_text(stmt, 5, pkg_terms->o_version, -1, NULL);
            sqlite3_bind_text(stmt, 6, pkg_terms->o_arch, -1, NULL);

            if (wm_vuldet_step(stmt) != SQLITE_DONE) {
                printf("Could not update the agent's CPE.\n");
                goto end;
            }
            sqlite3_finalize(stmt);

            if (add_cpe(pkg_terms->generated_cpe, node_list, min_cpe_index)) {
                printf("Could not parse '%s'.\n", pkg_terms->generated_cpe);
                goto end;
            }

            min_cpe_index--;
        }

        f_pkg_terms = pkg_terms;
        pkg_terms = pkg_terms->prev;
        free_search_terms(f_pkg_terms);
        free(f_pkg_terms);
    }


    if (insert_cpe_db(node_list, 0)) {
        printf("Could not insert the agent's CPEs in the database.\n");
    }

    printf("******** CPEs found: %d/%d ********\n", cpes_count, pkg_count);

    s_terms = NULL;
    stmt = NULL;
    success = 1;
end:
    if (node_list) {
        free(node_list);
    }

    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (s_terms) {
        for (pkg_terms = s_terms; pkg_terms;) {
            f_pkg_terms = pkg_terms;
            pkg_terms = pkg_terms->prev;
            free_search_terms(f_pkg_terms);
            free(f_pkg_terms);
        }
    }
    return !success;
}

int main(int argc, char **argv) {
    agent_software agent;
    sqlite3 *db;
    char agent_id[5];
    sqlite3_stmt *stmt = NULL;

    if (argc != 2) {
        printf("Use: %s <agent_id>\n", argv[0]);
        exit(1);
    }

    snprintf(agent_id, 4, "%03d", atoi(argv[1]));

    agent.agent_id = strdup(agent_id);

    if (sqlite3_open_v2(CPE_DB, &db, SQLITE_OPEN_READWRITE, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, NULL);
    }

    sqlite3_exec(db, vu_queries[VU_REMOVE_AGENTS_TABLE], NULL, NULL, NULL);
    sqlite3_exec(db, vu_queries[VU_REMOVE_AGENT_CPE], NULL, NULL, NULL);

    if (wm_vuldet_get_software_info(&agent, db, -47, -47)) {
        printf("ERROR: Could not get the agent package list.\n");
        return 1;
    }

    if (extract_agent_cpes(&agent, db)) {
        printf("ERROR: Could not decode the agent CPE list.\n");
        return 1;
    }

    if (update_agent_cpes(&agent, db)) {
        printf("ERROR: Could not update the agent CPEs.\n");
        return 1;
    }

    free(agent.agent_id);
    sqlite3_close_v2(db);
    return 0;
}
