#include "../external/wazuh_tools.h"

#define MAX_SIZE 6144
#define NVD_DB "nvd.db"

typedef struct nvd_references {
    char *url;
    char *name;
    char *refsource;
    char *tags;
} nvd_references;

typedef struct nvd_configuration {
    char *operator;
    char *vulnerable;
    char *cpe_uri23;
    char *versionEndIncluding;
} nvd_configuration;

typedef struct cv_scoring_system {
    char *version;
    char *vector_string;
    float base_score;
    float exploitability_score;
    float impact_score;
} cv_scoring_system;

typedef struct nvd_data {
    char *id;
    char *cwe;
    char *description;
    nvd_references *references;
    nvd_configuration *configuration;
    cv_scoring_system cvss;
    time_t published;
    time_t last_modified;
} nvd_data;

const char *NVD_STRING_PARSER[] = {
    "CVE_Items",
    "CVE_data_meta",
    "ID",
    "problemtype",
    "problemtype_data",
    "description",
    "value",
    "url",
    "name",
    "refsource",
    "tags",
    "description",
    "description_data",
    "value",
    "configuration",
    "nodes",
    "operator",
    "cpe_match",
    "vulnerable",
    "cpe23Uri",
    "versionEndIncluding",
    "versionEndExcluding",
    "versionStartIncluding",
    "versionStartExcluding",
    "impact",
    "baseMetricV2",
    "cvssV2",
    "vectorString",
    "CVE_data_meta",
    "ID",
    "problemtype",
    "problemtype_data",
    "description",
    "value",
    "references",
    "reference_data",
    "url",
    "name",
    "refsource",
    "tags",
    "description",
    "description_data",
    "value",
    "configurations",
    "nodes",
    "operator",
    "cpe_match",
    "vulnerable",
    "cpe23Uri",
    "versionEndIncluding",
    "impact",
    "baseMetricV2",
    "cvssV2",
    "vectorString",
    "accessVector",
    "accessComplexity",
    "authentication",
    "confidencialityImpact",
    "availabilityImpact",
    "baseScore",
    "severity",
    "exploitabilityScore",
    "impactScore",
    "obtainAllPrivilege",
    "obtainUserPrivilege",
    "obtainOtherPrivilege",
    "userInteractionRequired",
    "baseMetricV3",
    "cvssV3",
    "version",
    "vectorString",
    "attackVector",
    "attackComplexity",
    "privilegesRequired",
    "userInteraction",
    "scope",
    "confidentialityImpact",
    "integrityImpact",
    "availabilityImpact",
    "baseScore",
    "baseSeverity",
    "exploitabilityScore",
    "impactScor",
    "publishedDate",
    "lastModifiedDate",
};

/*
CVE_data_meta
    ID
problemtype
    problemtype_data
        description
            value
references
    reference_data
        url
        name
        refsource
        tags
description
    description_data
        value
configurations
    nodes
        operator
        cpe_match
            vulnerable
            cpe23Uri
            versionEndIncluding
impact
    baseMetricV2
        cvssV2
            vectorString
            accessVector
            accessComplexity
            authentication
            confidencialityImpact
            availabilityImpact
            baseScore
        severity
        exploitabilityScore
        impactScore
        obtainAllPrivilege
        obtainUserPrivilege
        obtainOtherPrivilege
        userInteractionRequired
    baseMetricV3
        cvssV3
            version
            vectorString
            attackVector
            attackComplexity
            privilegesRequired
            userInteraction
            scope
            confidentialityImpact
            integrityImpact
            availabilityImpact
            baseScore
            baseSeverity
        exploitabilityScore
        impactScore
publishedDate
lastModifiedDate
*/

extern const char *cpe_schema;

// Functions
cJSON * read_nvd_file();
int nvd_database_create();

int nvd_database_create() {
    if (wm_vuldet_create_file(NVD_DB, cpe_schema)) {
        printf("Could not create the database\n");
        return -1;
    }

    return 0;
}

// Return NULL on error
cJSON * read_nvd_file() {
    cJSON *json_feed = NULL;

    if (json_feed =  json_fread("./nvdcve-1.0-2014.json", 0), !json_feed) {
        printf("Error reading nvd file\n");
    }

    return json_feed;
}

int parse_nvd_json(cJSON *nvd_json) {
    cJSON *json_item;
    cJSON *cve_list;
    cJSON *cve_item;
    cJSON *ref;
    unsigned int i = 0;

    for (json_item = nvd_json->child; json_item; json_item = json_item->next) {
        //printf("item '%s'\n", json_item->string);
        if (!strcmp(json_item->string, NVD_STRING_PARSER[i])) {
            i++;
            for (cve_list = json_item->child; cve_list; cve_list = cve_list->next) {

                for(cve_item = json_item->child->child->child; cve_item; cve_item = cve_item->next) {

                    if (!strcmp(cve_item->string, NVD_STRING_PARSER[i])) {
                        printf("cve_id '%s'\n", cve_item->child->valuestring);
                        printf("cwe '%s'\n", cve_item->next->next->child->child->child->child->child->next->valuestring);
                        printf("cwe '%s'\n", cve_item->next->next->next->next->child->child->child->next->valuestring);

                        //parse_references(cve_item->next->next->next);
                        
                        for (ref = cve_item->next->next->next->child->child; ref; ref = ref->next) {
                            printf("url '%s'\n", ref->child->valuestring);
                            printf("name '%s'\n", ref->child->next->valuestring);
                            printf("refsource '%s'\n", ref->child->next->next->valuestring);
                            printf("tag '%s'\n", ref->child->next->next->next->valuestring);

                        }
                    }

                }
            }
        } else {
            continue;
        }
    }

    return 0;
}

int main() {
    printf("Generating NVD database\n");
    cJSON *nvd_json;

    nvd_database_create();
    if (nvd_json = read_nvd_file(), nvd_json) {
        parse_nvd_json(nvd_json);
    } else {
        printf("Error reading json\n");
    }

    return 0;
}