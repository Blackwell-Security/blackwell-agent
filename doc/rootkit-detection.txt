Rootkit detection techniques used by Rootcheck
to detect kernel-level and user-mode rootkits.
by Daniel B. Cid, dcid @ ossec.net


Rootkit detection is a job that is becoming harder every
day. Rootkit developers are becoming smarter and hiding
most of his tracks on kernel-level.


- How to check if a file exist. Most kernel level rootkits
in an attempt to hide their own files, disguise a few
system calls to make look that the file does not exist.
To bypass these limititation, we always try the following
calls for each file:

Attempt to chdir a file. If it works, it is because it
is a valid directory, if it  fails and the errno is set
to ENOTDIR, it is a valid file.
Try lstat, stat, access and open system calls on the file.
If any of them sucussed, the file is present.
Attempt to call opendir system call. If suceeds, it is a directory.
If it fails and errno is set to ENOTDIR, it is a existent
file.


- Check for hidden directories.

The stats system call return a great deal of information
about a file or a directory. In the directory case, the
nlink_t is the number of sub-directories that this directory
have. Knowing that, we open every directory and count
using readdir the number of sub-directories that it has.
If this number does not match the stats link counter,
something maybe hidden.
 

-Check for messages hidden in the file.

We open every file and count the number of bytes found
with read. The size must match with what the stats.st_size
returns.


Pids:

Scanning all pids in the system:

comparing getsid, kill 0, getpdgid, access of /proc and ps
outputs for anomalies.


The rootcheck will perform the following steps on the
system trying to find rootkits:


1- Read the rootkit_files.txt which contains a big database
   of rootkits and files used by them. It will try to stats,
   fopen and opendir each specified file. We use all these
   system calls, because some kernel-level rootkits, hide
   files from some system calls. The more system calls we
   try, the better the detection. This method is more like
   an anti-virus rule that needs to be updated constantly.
   The chances of false-positives are small, but false
   negatives can be produced by modifying the rootkits.

2- Read the rootkit_trojans.txt which contains a database
   of signatures of files trojaned by rootkits. This
   technique of modifying binaries with trojaned versions
   was commonly used by most of the popular rootkits 
   available. This detection method will not find any
   kernel level rootkit or any unknown rootkit.   
   
3- Scan the /dev directory looking for anomalies. The /dev
   should only have device files and the Makedev script.
   A lot of rootkits use the /dev to hide files. This 
   technique can detect even non-public rootkits.

4- Scan the whole filesystem looking for unusual files and
   permission problems. Files owned by root, with written
   permission to others are very dangerous and the rootkit
   detection will look for them. Suid files, hidden directories
   and files will also be inspected.

6- Look for the presence of hidden ports. We use bind() to
   check every tcp and udp port on the system. If we can't
   bind to the port (it's being used), but netstat does not
   show it, we probably have a rootkit installed.

7- Scan all interfaces on the system and look for the ones
   with "promisc" mode enabled. If the interface is in promiscuous
   mode, the output of "ifconfig" should show that. If not,
   we probably have a rootkit installed.


EOF
