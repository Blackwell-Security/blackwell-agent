' Copyright (C) 2015-2021, Wazuh Inc.
' Created by Wazuh, Inc. <info@wazuh.com>.
' This program is free software; you can redistribute it and/or modify it under the terms of GPLv2
@startuml remotd

    box "Remotd Module" #LightGrey
    participant remoted
    participant secure
    participant notify_op
    participant netbuffer
    participant state
    end box
    participant system

    remoted -> secure : HandleSecure()
    secure -> notify_op : wnotify_init(MAX_EVENTS) - 1024 Max number of epoll events
    secure <-- notify_op : return [notify]
    secure -> notify_op : wnotify_add(notify, add tcp socket)
    secure <-- notify_op :

    loop while (TRUE)

        secure -> notify_op : wnotify_wait(EPOLL_MILLIS)
        secure <-- notify_op : return [n_events]

        loop for (n_events)
            secure -> notify_op : wnotify_get(event by event)
            secure <-- notify_op : return [fd]

            alt #LightBlue A new TCP connection was received and TCP is enabled
                secure -> system: accept (tcp_sock, peer_info, peer_size)
                secure <-- system: return [sock_client]

                secure -> netbuffer: nb_open(&netbuffer, sock_client, &peer_info);
                secure <-- netbuffer :
                note right of netbuffer:Increase max_fd \n if it is neccesary,\n and copy peer info into \n buffer->buffers[sock].peer_info,

                secure -> state: rem_inc_tcp(tcp_sessions ++)
                secure <-- state:

                secure -> notify_op: wnotify_add(sock_client)
                secure <-- notify_op:

            else #Pink If a message was received through a TCP client and tcp is enabled

                secure -> netbuffer: nb_recv(&netbuffer, sock_client = fd)
                secure <-- netbuffer : return [recv_b]

            end
        end
    end
@enduml